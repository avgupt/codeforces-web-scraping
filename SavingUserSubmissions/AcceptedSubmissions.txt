["#include <iostream>", "#include <algorithm>", "#include <cmath>", "#include <vector>", "#include <functional>", "#include <cstdio>", "#include <array>", "#include <tuple>", "#include <unordered_map>", "#include <unordered_set>", "#include <queue>", "#include <set>", "#include <map>", "#include <list>", "#include <stack>", "#include <cstring>", "#include <string>", "#include <fstream>", "#include <sstream>", "#include <cstdlib>", "#include <iterator>", "using namespace std;", "const int INF = 0x3f3f3f3f;", "", "typedef long long ll;", "typedef pair<int, int> pii;", "", "ll N;", "ll arr[100100];", "", "ll freq[1200100];", "", "set <ll> primes;", "", "ll po(ll a, ll b) {", "\tll res = 1; for (int i = 0; i < b; ++i) res *= a;", "\treturn res;", "}", "", "int main(){", "    scanf(\"%lld\", &N);", "    for (int i = 0; i < N; i++) scanf(\"%lld\", &arr[i]);", "    for (int i = 0; i < N; i++){", "        for (int j = 2; j*j <= arr[i]; j++){", "            int num = 0;", "            if (arr[i]%j == 0) primes.insert(j);", "            while (arr[i]%j == 0){", "                num++;", "                freq[po(j,num)]++;", "                arr[i] /= j;", "            }", "        }", "        if (arr[i] > 1){", "            primes.insert(arr[i]);", "            freq[arr[i]]++;", "        }", "    }", "    ll ans = 1;", "    for (auto i = primes.begin(); i != primes.end(); i++){", "        int power = 1;", "        ll num = *i;", "        while (po(num, power) <= 1200000 && freq[po(num, power)] >= N-1){", "            power++;", "        }", "        ans *= po(num, power-1);", "    }", "    printf(\"%lld\", ans);", "}", ""]["#include <iostream>", "#include <algorithm>", "#include <cmath>", "#include <vector>", "#include <functional>", "#include <cstdio>", "#include <array>", "#include <tuple>", "#include <unordered_map>", "#include <unordered_set>", "#include <queue>", "#include <set>", "#include <map>", "#include <list>", "#include <stack>", "#include <cstring>", "#include <string>", "#include <fstream>", "#include <sstream>", "#include <cstdlib>", "#include <iterator>", "using namespace std;", "const int INF = 0x3f3f3f3f;", "", "typedef long long ll;", "typedef pair<int, int> pii;", "", "ll N;", "ll arr[100100];", "", "ll freq[1200100];", "", "set <ll> primes;", "", "int main(){", "    scanf(\"%lld\", &N);", "    for (int i = 0; i < N; i++) scanf(\"%lld\", &arr[i]);", "    for (int i = 0; i < N; i++){", "        for (int j = 2; j <= (ll)sqrt(arr[i]); j++){", "            int num = 0;", "            if (arr[i]%j == 0) primes.insert(j);", "            while (arr[i]%j == 0){", "                freq[(int)pow(j, num+1)]++;", "                arr[i] /= j;", "                num++;", "            }", "        }", "        if (arr[i] > 1){", "            primes.insert(arr[i]);", "            freq[arr[i]]++;", "        }", "    }", "    ll ans = 1;", "    for (auto i = primes.begin(); i != primes.end(); i++){", "        int power = 1;", "        ll num = *i;", "        while (pow(num, power) <= 1200000 && freq[(int)pow(num, power)] >= N-1){", "            power++;", "        }", "        ans *= pow(num, power-1);", "    }", "    printf(\"%lld\", ans);", "}", ""]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", "", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", "", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", "", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", "", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", "", "const int MOD = 1e9+7; // 998244353;", "const int MX = 2e5+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ", "", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", "", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", "", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", "", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", "", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", "", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", "", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", "", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", "", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", "", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", "", "ll a,b; ", "int n;", "", "void red() {", "\tll g = __gcd(a,b);", "\ttie(a,b) = mp(g,a/g*b); ", "}", "", "int main() {", "\tsetIO(); re(n);", "\tre(a,b);", "\tred();", "\tFOR(i,2,n) {", "\t\tll x; re(x); b = __gcd(b,x);", "\t\tred();", "\t}", "\tps(b);", "\t// you should actually read the stuff at the bottom", "}", "", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "\t* DON'T GET STUCK ON ONE APPROACH", "*/", ""]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", " ", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", " ", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", " ", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", " ", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", " ", "const int MOD = 1e7+7; // 777244353;", "const int MX = 2e5+5; ", "const ll INF = 1e17; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", " ", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", " ", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", " ", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", " ", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", " ", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", " ", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", " ", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", " ", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", " ", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", " ", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", " ", "constexpr array<int,1<<13> PCT = []{", "\tarray<int,1<<13> res{};", "\tF0R(i,1<<13) res[i] = __builtin_popcount(i);", "\treturn res;", "}();", " ", "int n,m,k;", "vi x, y;", "vpi v;", " ", "str st, en;", "vi ST, EN;", " ", "void swa(int& a, int x, int y) {", "\tif (((a>>x)&1) != ((a>>y)&1)) {", "\t\ta ^= 1<<x;", "\t\ta ^= 1<<y;", "\t}", "}", " ", "int con(str s) {", "\tint mask = 0;", "\tF0R(i,k) if (s[i] == '1') mask ^= 1<<i;", "\treturn mask;", "}", " ", "int dist[1<<7][1<<13], from[1<<7][1<<13];", "bool done[1<<20];", " ", " ", "int main() {", "\tsetIO(); re(n,m,k);", "\tre(st,en); v.rsz(n); re(v);", "\ttrav(t,v) t.f --, t.s --;", "\tint dif = n-m+1;", "\tST.rsz(dif), EN.rsz(dif);", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(st); // dbg(\"HA\",cur);", "\t\tR0F(i,n) {", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t\tif (i <= n-m) ST[i] = cur;", "\t\t}", "\t}", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(en);", "\t\tR0F(i,n) {", "\t\t\tif (i >= m-1) EN[i-(m-1)] = cur;", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t}", "\t}", "\tint ans = MOD;", "\tpi ind = {-1,-1};", "\tF0R(i,1<<13) F0R(j,1<<7) dist[j][i] = from[j][i] = MOD;", "\tR0F(i,dif) {", "\t\t{", "\t\t\tint x = EN[i];", "\t\t\tint lef = x&((1<<7)-1);", "\t\t\tif (!done[x]) {", "\t\t\t\tdone[x] = 1; ", "\t\t\t\t// int *DIST = dist[lef];", "\t\t\t\t// int *FROM = from[lef];", "\t\t\t\tconst int X = x>>7;", "\t\t\t\tF0R(a,1<<13) if (dist[lef][a] > PCT[a^X])", "\t\t\t\t\tdist[lef][a] = PCT[a^X], from[lef][a] = i;", "\t\t\t}", "\t\t}", "\t\t{", "\t\t\tint x = ST[i];", "\t\t\tint lef = x&((1<<7)-1);", "\t\t\tint ANS = ans;", "\t\t\tF0R(b,1<<7) ans = min(ans,dist[b][x>>7]+PCT[b^lef]);", "\t\t\tif (ans < ANS) F0R(b,1<<7) if (ans == dist[b][x>>7]+pct(b^lef))", "\t\t\t\tind = {i,from[b][x>>7]};", "\t\t}", "\t}", "\tps(k-ans);", "\tps(ind.f+1,ind.s+m);", "\t// you should actually read the stuff at the bottom", "}", " ", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/"]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", " ", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", " ", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", " ", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", " ", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", " ", "const int MOD = 1e7+7; // 777244353;", "const int MX = 2e5+5; ", "const ll INF = 1e17; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", " ", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", " ", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", " ", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", " ", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", " ", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", " ", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", " ", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", " ", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", " ", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", " ", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", " ", "constexpr array<int,1<<13> PCT = []{", "\tarray<int,1<<13> res{};", "\tF0R(i,1<<13) res[i] = __builtin_popcount(i);", "\treturn res;", "}();", " ", "int n,m,k;", "vi x, y;", "vpi v;", " ", "str st, en;", "vi ST, EN;", " ", "void swa(int& a, int x, int y) {", "\tif (((a>>x)&1) != ((a>>y)&1)) {", "\t\ta ^= 1<<x;", "\t\ta ^= 1<<y;", "\t}", "}", " ", "int con(str s) {", "\tint mask = 0;", "\tF0R(i,k) if (s[i] == '1') mask ^= 1<<i;", "\treturn mask;", "}", " ", "int dist[1<<7][1<<13], from[1<<7][1<<13];", "bool done[1<<20];", " ", " ", "int main() {", "\tsetIO(); re(n,m,k);", "\tre(st,en); v.rsz(n); re(v);", "\ttrav(t,v) t.f --, t.s --;", "\tint dif = n-m+1;", "\tST.rsz(dif), EN.rsz(dif);", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(st); // dbg(\"HA\",cur);", "\t\tR0F(i,n) {", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t\tif (i <= n-m) ST[i] = cur;", "\t\t}", "\t}", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(en);", "\t\tR0F(i,n) {", "\t\t\tif (i >= m-1) EN[i-(m-1)] = cur;", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t}", "\t}", "\tint ans = MOD;", "\tpi ind = {-1,-1};", "\tF0R(i,1<<13) F0R(j,1<<7) dist[j][i] = from[j][i] = MOD;", "\tR0F(i,dif) {", "\t\t{", "\t\t\tint x = EN[i];", "\t\t\tint lef = x&((1<<7)-1);", "\t\t\tif (!done[x]) {", "\t\t\t\tdone[x] = 1; ", "\t\t\t\tint *DIST = dist[lef];", "\t\t\t\tint *FROM = from[lef];", "\t\t\t\tconst int X = x>>7;", "\t\t\t\tF0R(a,1<<13) if (DIST[a] > PCT[a^X])", "\t\t\t\t\tDIST[a] = PCT[a^X], FROM[a] = i;", "\t\t\t}", "\t\t}", "\t\t{", "\t\t\tint x = ST[i];", "\t\t\tint lef = x&((1<<7)-1);", "\t\t\tint ANS = ans;", "\t\t\tF0R(b,1<<7) ans = min(ans,dist[b][x>>7]+PCT[b^lef]);", "\t\t\tif (ans < ANS) F0R(b,1<<7) if (ans == dist[b][x>>7]+pct(b^lef))", "\t\t\t\tind = {i,from[b][x>>7]};", "\t\t}", "\t}", "\tps(k-ans);", "\tps(ind.f+1,ind.s+m);", "\t// you should actually read the stuff at the bottom", "}", " ", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/"]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", " ", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", " ", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", " ", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", " ", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", " ", "const int MOD = 1e7+7; // 777244353;", "const int MX = 2e5+5; ", "const ll INF = 1e17; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", " ", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", " ", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", " ", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", " ", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", " ", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", " ", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", " ", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", " ", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", " ", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", " ", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", " ", "constexpr array<int,1<<13> PCT = []{", "\tarray<int,1<<13> res{};", "\tF0R(i,1<<13) res[i] = __builtin_popcount(i);", "\treturn res;", "}();", " ", "int n,m,k;", "vi x, y;", "vpi v;", " ", "str st, en;", "vi ST, EN;", " ", "void swa(int& a, int x, int y) {", "\tif (((a>>x)&1) != ((a>>y)&1)) {", "\t\ta ^= 1<<x;", "\t\ta ^= 1<<y;", "\t}", "}", " ", "int con(str s) {", "\tint mask = 0;", "\tF0R(i,k) if (s[i] == '1') mask ^= 1<<i;", "\treturn mask;", "}", " ", "int dist[1<<7][1<<13], from[1<<7][1<<13];", "bool done[1<<20];", " ", " ", "int main() {", "\tsetIO(); re(n,m,k);", "\tre(st,en); v.rsz(n); re(v);", "\ttrav(t,v) t.f --, t.s --;", "\tint dif = n-m+1;", "\tST.rsz(dif), EN.rsz(dif);", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(st); // dbg(\"HA\",cur);", "\t\tR0F(i,n) {", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t\tif (i <= n-m) ST[i] = cur;", "\t\t}", "\t}", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(en);", "\t\tR0F(i,n) {", "\t\t\tif (i >= m-1) EN[i-(m-1)] = cur;", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t}", "\t}", "\tint ans = MOD;", "\tpi ind = {-1,-1};", "\tF0R(i,1<<13) F0R(j,1<<7) dist[j][i] = from[j][i] = MOD;", "\tR0F(i,dif) {", "\t\t{", "\t\t\tint x = EN[i];", "\t\t\tint lef = x&((1<<7)-1);", "\t\t\tif (!done[x]) {", "\t\t\t\tdone[x] = 1; ", "\t\t\t\tint *DIST = dist[lef];", "\t\t\t\tint *FROM = from[lef];", "\t\t\t\tF0R(a,1<<13) if (DIST[a] > PCT[a^(x>>7)])", "\t\t\t\t\tDIST[a] = PCT[a^(x>>7)], FROM[a] = i;", "\t\t\t}", "\t\t}", "\t\t{", "\t\t\tint x = ST[i];", "\t\t\tint lef = x&((1<<7)-1);", "\t\t\tint ANS = ans;", "\t\t\tF0R(b,1<<7) ans = min(ans,dist[b][x>>7]+PCT[b^lef]);", "\t\t\tif (ans < ANS) F0R(b,1<<7) if (ans == dist[b][x>>7]+pct(b^lef))", "\t\t\t\tind = {i,from[b][x>>7]};", "\t\t}", "\t}", "\tps(k-ans);", "\tps(ind.f+1,ind.s+m);", "\t// you should actually read the stuff at the bottom", "}", " ", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/", ""]["#pragma GCC optimize(\"Ofast\")", "#pragma GCC target(\"avx2\")", "", "#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", " ", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", " ", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", " ", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", " ", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", " ", "const int MOD = 1e7+7; // 777244353;", "const int MX = 2e5+5; ", "const ll INF = 1e17; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", " ", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", " ", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", " ", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", " ", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", " ", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", " ", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", " ", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", " ", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", " ", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", " ", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", " ", "constexpr array<int,1<<13> PCT = []{", "\tarray<int,1<<13> res{};", "\tF0R(i,1<<13) res[i] = __builtin_popcount(i);", "\treturn res;", "}();", "", "int n,m,k;", "vi x, y;", "vpi v;", " ", "str st, en;", "vi ST, EN;", " ", "void swa(int& a, int x, int y) {", "\tif (((a>>x)&1) != ((a>>y)&1)) {", "\t\ta ^= 1<<x;", "\t\ta ^= 1<<y;", "\t}", "}", " ", "int con(str s) {", "\tint mask = 0;", "\tF0R(i,k) if (s[i] == '1') mask ^= 1<<i;", "\treturn mask;", "}", " ", "int dist[1<<7][1<<13], from[1<<7][1<<13];", "bool done[1<<20];", " ", " ", "int main() {", "\tsetIO(); re(n,m,k);", "\tre(st,en); v.rsz(n); re(v);", "\ttrav(t,v) t.f --, t.s --;", "\tint dif = n-m+1;", "\tST.rsz(dif), EN.rsz(dif);", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(st); // dbg(\"HA\",cur);", "\t\tR0F(i,n) {", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t\tif (i <= n-m) ST[i] = cur;", "\t\t}", "\t}", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(en);", "\t\tR0F(i,n) {", "\t\t\tif (i >= m-1) EN[i-(m-1)] = cur;", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t}", "\t}", "\tint ans = MOD;", "\tpi ind = {-1,-1};", "\tF0R(i,1<<13) F0R(j,1<<7) dist[j][i] = from[j][i] = MOD;", "\tR0F(i,dif) {", "\t\t{", "\t\t\tint x = EN[i];", "\t\t\tint lef = x&((1<<7)-1);", "\t\t\tif (!done[x]) {", "\t\t\t\tdone[x] = 1; ", "\t\t\t\tint *DIST = dist[lef];", "\t\t\t\tint *FROM = from[lef];", "\t\t\t\tF0R(a,1<<13) if (DIST[a] > PCT[a^(x>>7)])", "\t\t\t\t\tDIST[a] = PCT[a^(x>>7)], FROM[a] = i;", "\t\t\t}", "\t\t}", "\t\t{", "\t\t\tint x = ST[i];", "\t\t\tint lef = x&((1<<7)-1);", "\t\t\tint ANS = ans;", "\t\t\tF0R(b,1<<7) ans = min(ans,dist[b][x>>7]+PCT[b^lef]);", "\t\t\tif (ans < ANS) F0R(b,1<<7) if (ans == dist[b][x>>7]+pct(b^lef))", "\t\t\t\tind = {i,from[b][x>>7]};", "\t\t}", "\t}", "\tps(k-ans);", "\tps(ind.f+1,ind.s+m);", "\t// you should actually read the stuff at the bottom", "}", " ", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/"]["#pragma GCC optimize(\"Ofast\")", "#pragma GCC target(\"avx2\")", "", "#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", " ", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", " ", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", " ", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", " ", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", " ", "const int MOD = 1e8+7; // 888244353;", "const int MX = 2e5+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", " ", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", " ", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", " ", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", " ", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", " ", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", " ", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", " ", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", " ", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", " ", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", " ", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", " ", "constexpr array<int,1<<12> PCT = []{", "\tarray<int,1<<12> res{};", "\tF0R(i,1<<12) res[i] = __builtin_popcount(i);", "\treturn res;", "}();", "", "int n,m,k;", "vi x, y;", "vpi v;", " ", "str st, en;", "vi ST, EN;", " ", "void swa(int& a, int x, int y) {", "\tif (((a>>x)&1) != ((a>>y)&1)) {", "\t\ta ^= 1<<x;", "\t\ta ^= 1<<y;", "\t}", "}", " ", "int con(str s) {", "\tint mask = 0;", "\tF0R(i,k) if (s[i] == '1') mask ^= 1<<i;", "\treturn mask;", "}", " ", "int dist[1<<8][1<<12], from[1<<8][1<<12];", "bool done[1<<20];", " ", " ", "int main() {", "\tsetIO(); re(n,m,k);", "\tre(st,en); v.rsz(n); re(v);", "\ttrav(t,v) t.f --, t.s --;", "\tint dif = n-m+1;", "\tST.rsz(dif), EN.rsz(dif);", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(st); // dbg(\"HA\",cur);", "\t\tR0F(i,n) {", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t\tif (i <= n-m) ST[i] = cur;", "\t\t}", "\t}", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(en);", "\t\tR0F(i,n) {", "\t\t\tif (i >= m-1) EN[i-(m-1)] = cur;", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t}", "\t}", "\tint ans = MOD;", "\tpi ind = {-1,-1};", "\tF0R(i,1<<12) F0R(j,1<<8) dist[j][i] = from[j][i] = MOD;", "\tR0F(i,dif) {", "\t\t{", "\t\t\tint x = EN[i];", "\t\t\tint lef = x&((1<<8)-1);", "\t\t\tif (!done[x]) {", "\t\t\t\tdone[x] = 1; ", "\t\t\t\tint *DIST = dist[lef];", "\t\t\t\tint *FROM = from[lef];", "\t\t\t\tF0R(a,1<<12) if (DIST[a] > PCT[a^(x>>8)])", "\t\t\t\t\tDIST[a] = PCT[a^(x>>8)], FROM[a] = i;", "\t\t\t}", "\t\t}", "\t\t{", "\t\t\tint x = ST[i];", "\t\t\tint lef = x&((1<<8)-1);", "\t\t\tint ANS = ans;", "\t\t\tF0R(b,1<<8) ans = min(ans,dist[b][x>>8]+PCT[b^lef]);", "\t\t\tif (ans < ANS) F0R(b,1<<8) if (ans == dist[b][x>>8]+pct(b^lef))", "\t\t\t\tind = {i,from[b][x>>8]};", "\t\t}", "\t}", "\tps(k-ans);", "\tps(ind.f+1,ind.s+m);", "\t// you should actually read the stuff at the bottom", "}", " ", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/"]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", " ", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", " ", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", " ", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", " ", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", " ", "const int MOD = 1e9+7; // 998244353;", "const int MX = 2e5+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ", " ", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", " ", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", " ", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", " ", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", " ", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", " ", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", " ", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", " ", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", " ", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", " ", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", " ", "int n,m,k;", "vi x, y;", "vpi v;", " ", "str st, en;", "vi ST, EN;", " ", "void swa(int& a, int x, int y) {", "\tif (((a>>x)&1) != ((a>>y)&1)) {", "\t\ta ^= 1<<x;", "\t\ta ^= 1<<y;", "\t}", "}", " ", "int con(str s) {", "\tint mask = 0;", "\tF0R(i,k) if (s[i] == '1') mask ^= 1<<i;", "\treturn mask;", "}", " ", "pi dist[1<<20];", "", " ", "int main() {", "\tsetIO(); re(n,m,k);", "\tre(st,en); v.rsz(n); re(v);", "\ttrav(t,v) t.f --, t.s --;", "\tint dif = n-m+1;", "\tST.rsz(dif), EN.rsz(dif);", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(st); // dbg(\"HA\",cur);", "\t\tR0F(i,n) {", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t\tif (i <= n-m) ST[i] = cur;", "\t\t}", "\t}", "\t{", "\t\tvi fin(k); iota(all(fin),0);", "\t\tint cur = con(en);", "\t\tR0F(i,n) {", "\t\t\tif (i >= m-1) EN[i-(m-1)] = cur;", "\t\t\tswap(fin[v[i].f],fin[v[i].s]);", "\t\t\tswa(cur,fin[v[i].f],fin[v[i].s]);", "\t\t}", "\t}", "\tint ans = MOD;", "\tpi ind = {-1,-1};", "\tF0R(i,1<<k) dist[i] = {MOD,MOD};", "\tR0F(i,dif) {", "\t\tqueue<pi> q; q.push({EN[i],0});", "\t\twhile (sz(q)) {", "\t\t\tpi p = q.ft; q.pop();", "\t\t\tif (dist[p.f].f <= p.s) continue;", "\t\t\tdist[p.f] = {p.s,i};", "\t\t\tF0R(z,k) q.push({p.f^(1<<z),p.s+1});", "\t\t}", "\t\tif (dist[ST[i]].f < ans) {", "\t\t\tans = dist[ST[i]].f;", "\t\t\tind = {i,dist[ST[i]].s};", "\t\t}", "\t}", "\tps(k-ans);", "\tps(ind.f+1,ind.s+m);", "\t// you should actually read the stuff at the bottom", "}", " ", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/", ""]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", "", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", "", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", "", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", "", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", "", "const int MOD = 1e9+7; // 998244353;", "const int MX = 2e5+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ", "", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", "", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", "", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", "", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", "", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", "", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", "", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", "", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", "", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", "", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", "", "/**", " * Description: modular arithmetic operations ", " * Source: ", "\t* KACTL", "\t* https://codeforces.com/blog/entry/63903", "\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)", "\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)", "\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)", " * Verification: ", "\t* https://open.kattis.com/problems/modulararithmetic", " */", "", "template<int MOD, int RT> struct mint {", "\tstatic const int mod = MOD;", "\tstatic constexpr mint rt() { return RT; } // primitive root for FFT", "\tint v; explicit operator int() const { return v; } // explicit -> don't silently convert to int", "\tmint() { v = 0; }", "\tmint(ll _v) { v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;", "\t\tif (v < 0) v += MOD; }", "\tfriend bool operator==(const mint& a, const mint& b) { ", "\t\treturn a.v == b.v; }", "\tfriend bool operator!=(const mint& a, const mint& b) { ", "\t\treturn !(a == b); }", "\tfriend bool operator<(const mint& a, const mint& b) { ", "\t\treturn a.v < b.v; }", "\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }", "\tfriend str ts(mint a) { return ts(a.v); }", "   ", "\tmint& operator+=(const mint& m) { ", "\t\tif ((v += m.v) >= MOD) v -= MOD; ", "\t\treturn *this; }", "\tmint& operator-=(const mint& m) { ", "\t\tif ((v -= m.v) < 0) v += MOD; ", "\t\treturn *this; }", "\tmint& operator*=(const mint& m) { ", "\t\tv = (ll)v*m.v%MOD; return *this; }", "\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }", "\tfriend mint pow(mint a, ll p) {", "\t\tmint ans = 1; assert(p >= 0);", "\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;", "\t\treturn ans; }", "\tfriend mint inv(const mint& a) { assert(a.v != 0); ", "\t\treturn pow(a,MOD-2); }", "\t\t", "\tmint operator-() const { return mint(-v); }", "\tmint& operator++() { return *this += 1; }", "\tmint& operator--() { return *this -= 1; }", "\tfriend mint operator+(mint a, const mint& b) { return a += b; }", "\tfriend mint operator-(mint a, const mint& b) { return a -= b; }", "\tfriend mint operator*(mint a, const mint& b) { return a *= b; }", "\tfriend mint operator/(mint a, const mint& b) { return a /= b; }", "};", "", "typedef mint<MOD,5> mi; // 5 is primitive root for both common mods", "typedef vector<mi> vmi;", "typedef pair<mi,mi> pmi;", "typedef vector<pmi> vpmi;", "", "vector<vmi> scmb; // small combinations", "void genComb(int SZ) {", "\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;", "\tFOR(i,1,SZ) F0R(j,i+1) ", "\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);", "}", "", "/**", " * Description: Multiply two polynomials of modular ints. For xor convolution ", " \t* ignore \\texttt{m}. If product of sizes is at most a certain ", " \t* threshold (ex. 10000) then it's faster to multiply directly.", " * Time: O(N\\log N)", " * Source: ", " \t* KACTL", " \t* https://cp-algorithms.com/algebra/fft.html", " \t* https://csacademy.com/blog/fast-fourier-transform-and-variations-of-it", " \t* maroonrk", " * Verification: ", "\t* https://judge.yosupo.jp/problem/convolution_mod", "\t* SPOJ polymul, CSA manhattan, CF Perfect Encoding", "\t* http://codeforces.com/contest/632/problem/E", " */", "", "// #include \"ModInt.h\"", "// const int MOD = 998244353;", "", "template<class T> void fft(vector<T>& A, bool inv = 0) {", "\tint n = sz(A); assert((T::mod-1)%n == 0); vector<T> B(n);", "\tfor(int b = n/2; b; b /= 2, swap(A,B)) {", "\t\tT w = pow(T::rt(),(T::mod-1)/n*b), m = 1;", "\t\tfor(int i = 0; i < n; i += b*2, m *= w) F0R(j,b) {", "\t\t\tT u = A[i+j], v = A[i+j+b]*m;", "\t\t\tB[i/2+j] = u+v; B[i/2+j+n/2] = u-v;", "\t\t}", "\t}", "\tif (inv) { reverse(1+all(A)); ", "\t\tT z = T(1)/T(n); trav(t,A) t *= z; }", "}", "template<class T> vector<T> mul(vector<T> A, vector<T> B) { ", "\tif (!min(sz(A),sz(B))) return {};", "\tint s = sz(A)+sz(B)-1, n = 1; for (; n < s; n *= 2);", "\tbool eq = A == B; A.rsz(n), fft(A);", "\tif (eq) B = A; // squaring A, so remove one FFT", "\telse B.rsz(n), fft(B);", "\tF0R(i,n) A[i] *= B[i];", "\tfft(A,1); A.rsz(s); return A;", "}", "", "/**", " * Description: Multiply two polynomials with arbitrary modulus.", " * Source: maroonrk", " * Verification: see FFT", " */", "", "// #include \"FFT.h\"", "", "template<class M, class T> vector<M> go(vector<T> x, vector<T> y) {", "\tauto con = [](const vector<T>& v) {", "\t\tvector<M> w(sz(v)); F0R(i,sz(v)) w[i] = (int)v[i];", "\t\treturn w; };", "\treturn mul(con(x),con(y));", "}", "template<class T> vector<T> MUL(const vector<T>& A, const vector<T>& B) {", "\tusing m0 = mint<(997<<20)+1,3>;  auto c0 = go<m0>(A,B); // 2^20 * 997  + 1", "\tusing m1 = mint<(1003<<20)+1,6>; auto c1 = go<m1>(A,B); // 2^20 * 1003 + 1", "\tusing m2 = mint<(1005<<20)+1,7>; auto c2 = go<m2>(A,B); // 2^20 * 1005 + 1", "\tint n = sz(c0); vector<T> res(n);", "\tm1 r01 = 1/m1(m0::mod); m2 r02 = 1/m2(m0::mod), r12 = 1/m2(m1::mod);", "\tF0R(i,n) { // a is remainder mod m0::mod, b fixes it mod m1::mod", "\t\tint a = c0[i].v, b = ((c1[i]-a)*r01).v, c = (((c2[i]-a)*r02-b)*r12).v;", "\t\tres[i] = (T(c)*m1::mod+b)*m0::mod+a; // c fixes it mod m2::mod", "\t\tif (c > 0) res[i] -= (ll)m0::mod*(m1::mod)*(m2::mod);", "\t}", "\t// dbg(A,B,res);", "\treturn res;", "}", "", "int n,m,q;", "vi a,b;", "vi query;", "vl ans, tmp;", "", "void go() { // <= x", "\t// V+fake-E", "\tvl A(100005), B(100005);", "\ttrav(t,a) A[t] ++;", "\ttrav(t,b) B[t] ++;", "\tF0R(i,sz(a)-1) A[max(a[i],a[i+1])] --;", "\tF0R(i,sz(b)-1) B[max(b[i],b[i+1])] --;", "\t// F0R(i,10) dbg(i,A[i]);", "\tvl C = MUL(A,B);", "\tFOR(i,1,sz(C)) C[i] += C[i-1];", "\ttmp.clear();", "\ttrav(t,query) {", "\t\t// dbg(\"HUH\",t,C[t],a,b);", "\t\ttmp.pb(C[t]);", "\t}", "}", "", "int main() { // >= x", "\tsetIO(); re(n,m,q);", "\ta.rsz(n), b.rsz(m); query.rsz(q); ans.rsz(q);", "\tre(a,b,query);", "\ttrav(t,query) t --; // <= t", "\tgo();", "\t// dbg(tmp);", "\tF0R(i,q) ans[i] -= tmp[i];", "\ttrav(x,a) x *= -1;", "\ttrav(x,b) x *= -1;", "\ttrav(t,query) {", "\t\tt = -t-1;", "\t}", "\ttrav(x,a) x += 100001;", "\ttrav(x,b) x += 100001;", "\ttrav(x,query) x += 100001+100001;", "\tgo();", "\t// dbg(tmp);", "\tF0R(i,q) ans[i] += tmp[i];", "\ttrav(t,ans) ps(t);", "\t// you should actually read the stuff at the bottom", "}", "", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/", ""]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", "", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", "", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", "", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", "", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", "", "const int MOD = 1e9+7; // 998244353;", "const int MX = 2e5+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ", "", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", "", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", "", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", "", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", "", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", "", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", "", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", "", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", "", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", "", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", "", "int n;", "vl h;", "set<int> zero;", "", "int main() {", "\tsetIO(); re(n); h.rsz(n); re(h);", "\tll beg = h[0];", "\tzero.insert(-1);", "\tF0R(i,n-1) zero.insert(i);", "\tzero.insert(n-1);", "\tvl dif(n); F0R(i,n-1) dif[i] = h[i+1]-h[i];", "\tF0R(i,n-1) while (dif[i]) {", "\t\tif (zero.count(i)) {", "\t\t\tzero.erase(i); dif[i] --;", "\t\t\tcontinue;", "\t\t}", "\t\tauto X = prev(zero.find(i+1));", "\t\tif (X != begin(zero) || dif[i] < i+2) {", "\t\t\tll num = min(dif[i],(ll)i-*X); assert(num);", "\t\t\tzero.insert(*X+num); dif[i] -= num; dif[i+1] += num;", "\t\t\tif (X != begin(zero)) zero.erase(X);", "\t\t\telse beg ++;", "\t\t\tcontinue;", "\t\t}", "\t\tll it = dif[i]/(i+2); // every i+2: ", "\t\tbeg += it; dif[i+1] += it*(i+1); dif[i] %= i+2;", "\t}", "\t// F0R(j,dif[i]) {", "\t// \tdbg(\"HUH\",i);", "\t// \tif (zero.count(i)) zero.erase(i);", "\t// \telse {", "\t// \t\tauto X = prev(zero.find(i+1));", "\t// \t\tzero.insert(*X+1);", "\t// \t\tif (X != begin(zero)) zero.erase(X);", "\t// \t\telse beg++;", "\t// \t\tdif[i+1] ++;", "\t// \t\t// auto it = zero.insert(i).f;", "\t// \t\t// if (it != begin(zero)) zero.erase(prev(it));", "\t// \t\t// else beg ++;", "\t// \t\t// if (next(it) != end(zero)) zero.erase(next(it));", "\t// \t}", "\t// }", "\tdbg(zero);", "\tF0R(i,n) {", "\t\tpr(beg,' ');", "\t\tif (i < n-1) {", "\t\t\tbeg += !zero.count(i);", "\t\t}", "\t}", "\t// you should actually read the stuff at the bottom", "}", "", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/", ""]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", "", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", "", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", "", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", "", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", "", "const int MOD = 998244353;", "const int MX = 2e6+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ", "", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", "", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", "", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", "", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", "", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", "", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", "", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", "", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", "", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", "", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", "", "/**", " * Description: modular arithmetic operations ", " * Source: ", "\t* KACTL", "\t* https://codeforces.com/blog/entry/63903", "\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)", "\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)", "\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)", " * Verification: ", "\t* https://open.kattis.com/problems/modulararithmetic", " */", "", "template<int MOD, int RT> struct mint {", "\tstatic const int mod = MOD;", "\tstatic constexpr mint rt() { return RT; } // primitive root for FFT", "\tint v; explicit operator int() const { return v; } // explicit -> don't silently convert to int", "\tmint() { v = 0; }", "\tmint(ll _v) { v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;", "\t\tif (v < 0) v += MOD; }", "\tfriend bool operator==(const mint& a, const mint& b) { ", "\t\treturn a.v == b.v; }", "\tfriend bool operator!=(const mint& a, const mint& b) { ", "\t\treturn !(a == b); }", "\tfriend bool operator<(const mint& a, const mint& b) { ", "\t\treturn a.v < b.v; }", "\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }", "\tfriend str ts(mint a) { return ts(a.v); }", "   ", "\tmint& operator+=(const mint& m) { ", "\t\tif ((v += m.v) >= MOD) v -= MOD; ", "\t\treturn *this; }", "\tmint& operator-=(const mint& m) { ", "\t\tif ((v -= m.v) < 0) v += MOD; ", "\t\treturn *this; }", "\tmint& operator*=(const mint& m) { ", "\t\tv = (ll)v*m.v%MOD; return *this; }", "\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }", "\tfriend mint pow(mint a, ll p) {", "\t\tmint ans = 1; assert(p >= 0);", "\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;", "\t\treturn ans; }", "\tfriend mint inv(const mint& a) { assert(a.v != 0); ", "\t\treturn pow(a,MOD-2); }", "\t\t", "\tmint operator-() const { return mint(-v); }", "\tmint& operator++() { return *this += 1; }", "\tmint& operator--() { return *this -= 1; }", "\tfriend mint operator+(mint a, const mint& b) { return a += b; }", "\tfriend mint operator-(mint a, const mint& b) { return a -= b; }", "\tfriend mint operator*(mint a, const mint& b) { return a *= b; }", "\tfriend mint operator/(mint a, const mint& b) { return a /= b; }", "};", "", "typedef mint<MOD,5> mi; // 5 is primitive root for both common mods", "typedef vector<mi> vmi;", "typedef pair<mi,mi> pmi;", "typedef vector<pmi> vpmi;", "", "vector<vmi> scmb; // small combinations", "void genComb(int SZ) {", "\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;", "\tFOR(i,1,SZ) F0R(j,i+1) ", "\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);", "}", "", "/**", " * Description: pre-compute factorial mod inverses,", " \t* assumes $MOD$ is prime and $SZ < MOD$.", " * Time: O(SZ)", " * Source: KACTL", " * Verification: https://dmoj.ca/problem/tle17c4p5", " */", "", "vi invs, fac, ifac; // make sure to convert to LL before doing any multiplications ...", "void genFac(int SZ) {", "\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ); ", "\tinvs[1] = fac[0] = ifac[0] = 1; ", "\tFOR(i,2,SZ) invs[i] = MOD-(ll)MOD/i*invs[MOD%i]%MOD;", "\tFOR(i,1,SZ) {", "\t\tfac[i] = (ll)fac[i-1]*i%MOD;", "\t\tifac[i] = (ll)ifac[i-1]*invs[i]%MOD;", "\t}", "}", "", "mi comb(int a, int b) {", "\tif (a < b || b < 0) return 0;", "\treturn (ll)fac[a]*ifac[b]%MOD*ifac[a-b]%MOD;", "}", "", "int n,m,x;", "mi ex[MX];", "", "int main() {", "\tsetIO(); re(n,m);", "\tgenFac(4000005);", "\t// say set has size x", "\t// if one of set comes before first joker -> DONE", "\t// if all of set comes after first joker -> DONE", "\t// n-x that come before", "\t// FFT?", "\tFOR(x,1,n+1) {", "\t\tmi con = 0, lin = 0;", "\t\t{", "\t\t\tmi prob = mi(m)*invs[m+x];", "\t\t\tmi b = 1+mi(n-x)*invs[m+x+1];", "\t\t\tlin += prob;", "\t\t\tcon += prob*b;", "\t\t\t// ex[x] = m/(m+x)*(+ex[x]);", "\t\t} ", "\t\t{", "\t\t\tmi prob = mi(x)*invs[m+x];", "\t\t\tmi pos = 2+mi(x-1)*invs[m+1];", "\t\t\tmi add = (n-x)*pos*invs[m+x+1];", "\t\t\tcon += prob*(pos+add);", "\t\t\t// ex[x] += x/(m+x)*(pos+add);", "\t\t}", "\t\t// ex = lin*ex+con ", "\t\tex[x] = con*(m+x)*invs[x];", "\t\t// expected position: 1+(x-1)/(m+1)+1", "\t\t// add: (n-x)*pos/(m+x+1)", "", "\t\t// m/(m+x) -> continue", "\t\t\t// 1+(n-x)/(x+m+1)", "\t\t// x/(m+x) -> OK", "\t}", "\tmi ans = 0;", "\tFOR(x,1,n+1) {", "\t\tif (x&1) ans += comb(n,x)*ex[x];", "\t\telse ans -= comb(n,x)*ex[x];", "\t}", "\tps(ans);", "\t// you should actually read the stuff at the bottom", "}", "", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/", ""]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", "", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", "", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", "", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", "", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", "", "const int MOD = 1e9+7; // 998244353;", "const int MX = 2e5+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ", "", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", "", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", "", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", "", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", "", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", "", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", "", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", "", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { cout << endl; } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", "", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", "", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", "", "int n;", "", "int main() {", "\tre(n);", "\tdbg(n);", "\tF0R(i,n) {", "\t\tF0R(j,n) {", "\t\t\tif (j%2 == 1) pr(1LL<<(i+j));", "\t\t\telse pr(0);", "\t\t\tpr(\" \");", "\t\t}", "\t\tps();", "\t}", "\tint q; re(q);", "\tF0R(i,q) {", "\t\tll k; re(k);", "\t\tvpi v = {{0,0}};", "\t\tFOR(sum,1,2*n-1) {", "\t\t\tint des = 0;", "\t\t\tif (k&(1LL<<sum)) des = 1;", "\t\t\t// dbg(\"HA\",v.bk,des);", "\t\t\tif (v.bk.s%2 == des) v.pb({v.bk.f+1,v.bk.s});", "\t\t\telse v.pb({v.bk.f,v.bk.s+1});", "\t\t}", "\t\ttrav(t,v) ps(t.f+1,t.s+1);", "\t}", "\t// you should actually read the stuff at the bottom", "}", "", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/", ""]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", "", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", "", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", "", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", "", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", "", "const int MOD = 1e9+7; // 998244353;", "const int MX = 2e5+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ", "", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", "", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", "", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", "", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", "", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", "", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", "", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", "", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", "", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", "", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", "", "int n;", "ll ans;", "str s;", "ll dp[MX];", "", "int val(int a, str b) {", "\tint cnt = 0;", "\tF0R(i,sz(b)) if (s[a-sz(b)+i] != b[i]) cnt ++;", "\treturn cnt;", "}", "", "void go() {", "\tdp[0] = 0;", "\tFOR(i,1,n+1) {", "\t\tdp[i] = INF;", "\t\tif (i >= 2) ckmin(dp[i],dp[i-2]+val(i,\"RL\"));", "\t\tif (i >= 3) ckmin(dp[i],dp[i-3]+val(i,\"RRL\"));", "\t\tif (i >= 3) ckmin(dp[i],dp[i-3]+val(i,\"RLL\"));", "\t\tif (i >= 4) ckmin(dp[i],dp[i-4]+val(i,\"RRLL\"));", "\t}", "\tckmin(ans,dp[n]);", "}", "", "void solve() {", "\tre(n,s); ans = MOD;", "\tF0R(i,6) {", "\t\tgo();", "\t\trotate(begin(s),1+all(s));", "\t}", "\tps(ans);", "}", "", "int main() {", "\tsetIO();", "\tint T; re(T);", "\tF0R(i,T) {", "\t\tsolve();", "\t}", "\t// you should actually read the stuff at the bottom", "}", "", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/", ""]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", "", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", "", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", "", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", "", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", "", "const int MOD = 1e9+7; // 998244353;", "const int MX = 2e5+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ", "", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", "", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", "", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", "", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", "", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", "", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", "", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", "", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", "", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", "", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", "", "int n; ll k;", "", "void solve() {", "\tre(n);", "\tvl a(n); re(a);", "\tll ans = 0;", "\tF0R(i,n-1) ans += max(a[i]-a[i+1],0LL);", "\tps(ans);", "}", "", "int main() {", "\tsetIO();", "\tint T; re(T);", "\tF0R(i,T) {", "\t\tsolve();", "\t}", "\t// you should actually read the stuff at the bottom", "}", "", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/", ""]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", "", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", "", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", "", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", "", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", "", "const int MOD = 1e9+7; // 998244353;", "const int MX = 2e5+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ", "", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", "", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", "", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", "", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", "", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", "", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", "", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", "", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", "", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", "", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", "", "int n; ll k;", "", "void solve() {", "\tre(n,k);", "\tvl a(n); re(a);", "\tif (k&1) {", "\t\ttrav(t,a) t *= -1;", "\t}", "\tll mn = INF; trav(t,a) ckmin(mn,t);", "\ttrav(t,a) t -= mn;", "\ttrav(t,a) pr(t,' ');", "\tps();", "}", "", "int main() {", "\tsetIO();", "\tint T; re(T);", "\tF0R(i,T) {", "\t\tsolve();", "\t}", "\t// you should actually read the stuff at the bottom", "}", "", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/", ""]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", "", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", "", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", "", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", "", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", "", "const int MOD = 1e9+7; // 998244353;", "const int MX = 2e5+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ", "", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", "", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", "", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", "", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", "", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", "", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", "", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", "", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", "", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", "", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", "", "int main() {", "\tsetIO();", "\tint T; re(T);", "\tF0R(i,T) {", "\t\tint n; re(n); vi a(n); re(a);", "\t\tbool ok = 0;", "\t\tFOR(i,1,n) if (a[i] != a[0]) ok = 1;", "\t\tif (ok) ps(1);", "\t\telse ps(n);", "\t}", "\t// you should actually read the stuff at the bottom", "}", "", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/", ""]["#pragma GCC optimize (\"O3\")", "#pragma GCC target (\"sse4\")", " ", "#include <bits/stdc++.h>", "#include <ext/pb_ds/tree_policy.hpp>", "#include <ext/pb_ds/assoc_container.hpp>", "#include <ext/rope>", " ", "using namespace std;", "using namespace __gnu_pbds;", "using namespace __gnu_cxx;", " ", "typedef long long ll;", "typedef long double ld;", "typedef complex<ld> cd;", " ", "typedef pair<int, int> pi;", "typedef pair<ll,ll> pl;", "typedef pair<ld,ld> pd;", " ", "typedef vector<int> vi;", "typedef vector<ld> vd;", "typedef vector<ll> vl;", "typedef vector<pi> vpi;", "typedef vector<pl> vpl;", "typedef vector<cd> vcd;", " ", "template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;", " ", "#define FOR(i, a, b) for (int i = (a); i < (b); i++)", "#define F0R(i, a) for (int i = 0; i < (a); i++)", "#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)", "#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)", "#define trav(a, x) for (auto& a : x)", " ", "#define mp make_pair", "#define pb push_back", "#define f first", "#define s second", "#define lb lower_bound", "#define ub upper_bound", " ", "#define sz(x) (int)x.size()", "#define beg(x) x.begin()", "#define en(x) x.end()", "#define all(x) beg(x), en(x)", "#define resz resize", " ", "const int MOD = 1000000007; // 998244353", "const ll INF = 1e18;", "const int MX = 100001;", "const ld PI = 4*atan((ld)1);", " ", "template<class T> void ckmin(T &a, T b) { a = min(a, b); }", "template<class T> void ckmax(T &a, T b) { a = max(a, b); }", " ", "namespace input {", "    template<class T> void re(complex<T>& x);", "    template<class T1, class T2> void re(pair<T1,T2>& p);", "    template<class T> void re(vector<T>& a);", "    template<class T, size_t SZ> void re(array<T,SZ>& a);", " ", "    template<class T> void re(T& x) { cin >> x; }", "    void re(double& x) { string t; re(t); x = stod(t); }", "    void re(ld& x) { string t; re(t); x = stold(t); }", "    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { ", "        re(first); re(rest...); ", "    }", " ", "    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }", "    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }", "    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }", "    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }", "}", " ", "using namespace input;", " ", "namespace output {", "    template<class T1, class T2> void pr(const pair<T1,T2>& x);", "    template<class T, size_t SZ> void pr(const array<T,SZ>& x);", "    template<class T> void pr(const vector<T>& x);", "    template<class T> void pr(const set<T>& x);", "    template<class T1, class T2> void pr(const map<T1,T2>& x);", " ", "    template<class T> void pr(const T& x) { cout << x; }", "    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { ", "        pr(first); pr(rest...); ", "    }", " ", "    template<class T1, class T2> void pr(const pair<T1,T2>& x) { ", "        pr(\"{\",x.f,\", \",x.s,\"}\"); ", "    }", "    template<class T> void prContain(const T& x) {", "        pr(\"{\");", "        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; ", "        pr(\"}\");", "    }", "    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }", "    template<class T> void pr(const vector<T>& x) { prContain(x); }", "    template<class T> void pr(const set<T>& x) { prContain(x); }", "    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }", "    ", "    void ps() { cout << endl; } ", "    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { ", "        pr(first,\" \"); ps(rest...); // print w/ spaces", "    }", "}", " ", "using namespace output;", " ", "namespace io {", "    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }", "    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }", "    void setIO(string s = \"\") {", "        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O", "        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "    }", "}", " ", "using namespace io;", " ", "template<class T> T invGeneral(T a, T b) {", "    a %= b; if (a == 0) return b == 1 ? 0 : -1;", "    T x = invGeneral(b,a); ", "    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;", "}", " ", "template<class T> struct modInt {", "    T val;", "    T mod = 0;", "    // static const T mod = MOD;", " ", "    void normalize() {", "        if (mod == 0) return;", "        val %= mod; if (val < 0) val += mod;", "    }", "    modInt(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }", "    // modInt(T v = 0, T m = 0) : val(v) { normalize(); }", " ", "    explicit operator T() const { return val; }", "    friend ostream& operator<<(ostream& os, const modInt& a) { return os << a.val; }", "    friend bool operator==(const modInt& a, const modInt& b) { return a.val == b.val; }", "    friend bool operator!=(const modInt& a, const modInt& b) { return !(a == b); }", " ", "    friend void check(modInt& a, modInt& b) { // make sure all operations are valid", "        // comment out if mod is static const", "        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }", "        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;", "        if (a.mod != mod) { a.mod = mod; a.normalize(); }", "        if (b.mod != mod) { b.mod = mod; b.normalize(); }", "    }", "    friend modInt operator+(modInt a, modInt b) {", "        check(a,b); a.val += (T)b;", "        if (a.val >= a.mod) a.val -= a.mod;", "        return a;", "    }", "    friend modInt operator-(modInt a, modInt b) {", "        check(a,b); a.val -= (T)b; ", "        if (a.val < 0) a.val += a.mod; ", "        return a;", "    }", "    friend modInt operator-(const modInt& a) { return modInt(0)-a; }", " ", "    friend modInt operator*(modInt a, modInt b) {", "        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;", "    }", "    friend modInt exp(modInt a, ll p) {", "        modInt ans(1,a.mod);", "        for (; p; p /= 2, a *= a) if (p&1) ans *= a;", "        return ans;", "    }", "    friend modInt inv(const modInt& a) {", "        return {invGeneral(a.val,a.mod),a.mod};", "        // return exp(b,b.mod-2) if prime", "    }", "    friend modInt operator/(modInt a, modInt b) { ", "        check(a,b); return a*inv(b); ", "    }", "};", " ", "typedef modInt<int> mi;", "typedef pair<mi,mi> pmi;", "typedef vector<mi> vmi;", "typedef vector<pmi> vpmi;", " ", "vi query(vi x) {", "    cout << \"next\";", "    trav(i,x) cout << \" \" << i;", "    cout << endl;", "    int k; re(k);", "    vi cat(10);", "    F0R(i,k) {", "        string z; re(z);", "        trav(a,z) cat[a-'0'] = i;", "    }", "    return cat;", "}", " ", "vi a;", " ", "int main() {", "    // you should actually read the stuff at the bottom", "    setIO(); ", "    while (1) {", "        a = query({0,1}); a = query({0});", "        if (a[0] == a[1]) break;", "    }", "    while (1) {", "        vi v; F0R(i,10) v.pb(i);", "        a = query(v);", "        if (a[0] == a[2]) break;", "    }", "    cout << \"done\" << endl;", "    // you should actually read the stuff at the bottom", "}", " ", "/* stuff you should look for", "    * int overflow, array bounds", "    * special cases (n=1?), set tle", "    * do smth instead of nothing and stay organized", "*/"]["#pragma GCC optimize (\"Ofast\")", "#pragma GCC target (\"avx2\")", " ", "#include <bits/stdc++.h>", "#include <ext/pb_ds/tree_policy.hpp>", "#include <ext/pb_ds/assoc_container.hpp>", "#include <ext/rope>", " ", "using namespace std;", "using namespace __gnu_pbds;", "using namespace __gnu_cxx;", " ", "typedef long long ll;", "typedef long double ld;", "typedef complex<ld> cd;", " ", "typedef pair<int, int> pi;", "typedef pair<ll,ll> pl;", "typedef pair<ld,ld> pd;", " ", "typedef vector<int> vi;", "typedef vector<ld> vd;", "typedef vector<ll> vl;", "typedef vector<pi> vpi;", "typedef vector<pl> vpl;", "typedef vector<cd> vcd;", " ", "template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;", " ", "#define FOR(i, a, b) for (int i = (a); i < (b); i++)", "#define F0R(i, a) for (int i = 0; i < (a); i++)", "#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)", "#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)", "#define trav(a, x) for (auto& a : x)", " ", "#define mp make_pair", "#define pb push_back", "#define f first", "#define s second", "#define lb lower_bound", "#define ub upper_bound", " ", "#define sz(x) (int)x.size()", "#define beg(x) x.begin()", "#define en(x) x.end()", "#define all(x) beg(x), en(x)", "#define resz resize", " ", "const int MOD = 1000000007; // 998244353", "const ll INF = 1e18;", "const int MX = 100001;", "const ld PI = 4*atan((ld)1);", " ", "template<class T> void ckmin(T &a, T b) { a = min(a, b); }", "template<class T> void ckmax(T &a, T b) { a = max(a, b); }", " ", "namespace io {", "    // TYPE ID (StackOverflow)", "    ", "    template<class T> struct like_array : is_array<T>{};", "    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};", "    template<class T> struct like_array<vector<T>> : true_type{};", "    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }", " ", "    // I/O ", "    ", "    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }", "    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }", "    void setIO(string s = \"\") {", "        ios_base::sync_with_stdio(0); cin.tie(0);", "        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }", "    }", "    ", "    // INPUT ", "    ", "    template<class T> void re(T& x) { cin >> x; }", "    template<class Arg, class... Args> void re(Arg& first, Args&... rest);", "    void re(double& x) { string t; re(t); x = stod(t); }", "    void re(ld& x) { string t; re(t); x = stold(t); }", "    ", "    template<class T> void re(complex<T>& x);", "    template<class T1, class T2> void re(pair<T1,T2>& p);", "    template<class T> void re(vector<T>& a);", "    template<class T, size_t SZ> void re(array<T,SZ>& a);", "    ", "    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }", "    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }", "    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }", "    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }", "    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }", "    ", "    // OUTPUT ", "    ", "    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {", "        os << '{' << a.f << \", \" << a.s << '}'; return os;", "    }", "    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {", "        os << '{';", "        F0R(i,SZ) {", "            if (i) {", "                os << \", \";", "                if (is_like_array(a[i])) cout << \"\\n\";", "            }", "            os << a[i];", "        }", "        os << '}';", "        return os;", "    }", "    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {", "        return printArray(os,a,SZ);", "    }", "    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {", "        return printArray(os,a,sz(a));", "    }", "    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {", "        os << vector<T>(all(a)); return os;", "    }", "    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {", "        os << vector<pair<T1,T2>>(all(a)); return os;", "    }", "    ", "    template<class T> void pr(const T& x) { cout << x << '\\n'; }", "    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { ", "        cout << first << ' '; pr(rest...); ", "    }", "}", " ", "using namespace io;", " ", "namespace modOp {", "    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }", "    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }", "    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }", "    ", "    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }", "    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }", "    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }", "    ", "    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }", "    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }", "    ", "    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1", "        if (a == 0) return b == 1 ? 0 : -1;", "        int x = invGeneral(b%a,a); ", "        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;", "    }", "}", " ", "using namespace modOp;", " ", "int q, mx[MX], mn[MX];", " ", "int ran() {", "    return rand()^(rand()<<15);", "}", " ", "int main() {", "    setIO(); re(q);", "\tF0R(i,MX) mx[i] = -MOD, mn[i] = MOD;", "\tF0R(i,q) {", "\t    int t,l,r,k; re(t,l,r);", "\t    /*t = ran() % 2+1;", "\t    l = ran() % 100000+1;", "\t    r = ran() % 100000+1;", "\t    if (l > r) swap(l,r);", "\t    k = ran() % 200000-100000;*/", "\t    ", "\t    if (t == 1) {", "\t        re(k);", "    \t    if (k > 0) FOR(j,l,r) ckmin(mn[j],k);", "    \t    else FOR(j,l,r) ckmax(mx[j],k);", "\t    } else {", "\t        ll ans = 0;", "\t        FOR(j,l,r) ans += (mn[j]-mx[j])*(mx[j] != -MOD)*(mn[j] != MOD);", "\t        cout << ans << \"\\n\";", "\t    }", "\t}", "}", " ", "/* stuff you should look for", "    * int overflow, array bounds", "    * special cases (n=1?), set tle", "    * do smth instead of nothing and stay organized", "*/", ""]["#pragma GCC optimize (\"Ofast\", \"unroll-loops\")", "#pragma GCC target (\"avx2\")", " ", "#include <bits/stdc++.h>", "#include <ext/pb_ds/tree_policy.hpp>", "#include <ext/pb_ds/assoc_container.hpp>", "#include <ext/rope>", " ", "using namespace std;", "using namespace __gnu_pbds;", "using namespace __gnu_cxx;", " ", "typedef long long ll;", "typedef long double ld;", "typedef complex<ld> cd;", " ", "typedef pair<int, int> pi;", "typedef pair<ll,ll> pl;", "typedef pair<ld,ld> pd;", " ", "typedef vector<int> vi;", "typedef vector<ld> vd;", "typedef vector<ll> vl;", "typedef vector<pi> vpi;", "typedef vector<pl> vpl;", "typedef vector<cd> vcd;", " ", "template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;", " ", "#define FOR(i, a, b) for (int i = (a); i < (b); i++)", "#define F0R(i, a) for (int i = 0; i < (a); i++)", "#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)", "#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)", "#define trav(a, x) for (auto& a : x)", " ", "#define mp make_pair", "#define pb push_back", "#define f first", "#define s second", "#define lb lower_bound", "#define ub upper_bound", " ", "#define sz(x) (int)x.size()", "#define beg(x) x.begin()", "#define en(x) x.end()", "#define all(x) beg(x), en(x)", "#define resz resize", " ", "const int MOD = 1000000007; // 998244353", "const ll INF = 1e18;", "const int MX = 100001;", "const ld PI = 4*atan((ld)1);", " ", "template<class T> void ckmin(T &a, T b) { a = min(a, b); }", "template<class T> void ckmax(T &a, T b) { a = max(a, b); }", " ", "namespace io {", "    // TYPE ID (StackOverflow)", "    ", "    template<class T> struct like_array : is_array<T>{};", "    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};", "    template<class T> struct like_array<vector<T>> : true_type{};", "    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }", " ", "    // I/O ", "    ", "    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }", "    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }", "    void setIO(string s = \"\") {", "        ios_base::sync_with_stdio(0); cin.tie(0);", "        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }", "    }", "    ", "    // INPUT ", "    ", "    template<class T> void re(T& x) { cin >> x; }", "    template<class Arg, class... Args> void re(Arg& first, Args&... rest);", "    void re(double& x) { string t; re(t); x = stod(t); }", "    void re(ld& x) { string t; re(t); x = stold(t); }", "    ", "    template<class T> void re(complex<T>& x);", "    template<class T1, class T2> void re(pair<T1,T2>& p);", "    template<class T> void re(vector<T>& a);", "    template<class T, size_t SZ> void re(array<T,SZ>& a);", "    ", "    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }", "    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }", "    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }", "    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }", "    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }", "    ", "    // OUTPUT ", "    ", "    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {", "        os << '{' << a.f << \", \" << a.s << '}'; return os;", "    }", "    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {", "        os << '{';", "        F0R(i,SZ) {", "            if (i) {", "                os << \", \";", "                if (is_like_array(a[i])) cout << \"\\n\";", "            }", "            os << a[i];", "        }", "        os << '}';", "        return os;", "    }", "    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {", "        return printArray(os,a,SZ);", "    }", "    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {", "        return printArray(os,a,sz(a));", "    }", "    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {", "        os << vector<T>(all(a)); return os;", "    }", "    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {", "        os << vector<pair<T1,T2>>(all(a)); return os;", "    }", "    ", "    template<class T> void pr(const T& x) { cout << x << '\\n'; }", "    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { ", "        cout << first << ' '; pr(rest...); ", "    }", "}", " ", "using namespace io;", " ", "namespace modOp {", "    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }", "    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }", "    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }", "    ", "    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }", "    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }", "    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }", "    ", "    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }", "    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }", "    ", "    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1", "        if (a == 0) return b == 1 ? 0 : -1;", "        int x = invGeneral(b%a,a); ", "        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;", "    }", "}", " ", "using namespace modOp;", " ", "int q, mx[MX], mn[MX];", " ", "int ran() {", "    return rand()^(rand()<<15);", "}", " ", "int main() {", "    setIO(); re(q);", "\tF0R(i,MX) mx[i] = -MOD, mn[i] = MOD;", "\tF0R(i,q) {", "\t    int t,l,r,k; re(t,l,r);", "\t    /*t = ran() % 2+1;", "\t    l = ran() % 100000+1;", "\t    r = ran() % 100000+1;", "\t    if (l > r) swap(l,r);", "\t    k = ran() % 200000-100000;*/", "\t    ", "\t    if (t == 1) {", "\t        re(k);", "    \t    if (k > 0) FOR(j,l,r) ckmin(mn[j],k);", "    \t    else FOR(j,l,r) ckmax(mx[j],k);", "\t    } else {", "\t        ll ans = 0;", "\t        FOR(j,l,r) ans += (mn[j]-mx[j])*(mx[j] != -MOD)*(mn[j] != MOD);", "\t        cout << ans << \"\\n\";", "\t    }", "\t}", "}", " ", "/* stuff you should look for", "    * int overflow, array bounds", "    * special cases (n=1?), set tle", "    * do smth instead of nothing and stay organized", "*/"]["#pragma GCC optimize (\"O3\")", "// #pragma GCC target (\"avx2\")", " ", "#include <bits/stdc++.h>", "#include <ext/pb_ds/tree_policy.hpp>", "#include <ext/pb_ds/assoc_container.hpp>", "#include <ext/rope>", " ", "using namespace std;", "using namespace __gnu_pbds;", "using namespace __gnu_cxx;", " ", "typedef long long ll;", "typedef long double ld;", "typedef complex<ld> cd;", " ", "typedef pair<int, int> pi;", "typedef pair<ll,ll> pl;", "typedef pair<ld,ld> pd;", " ", "typedef vector<int> vi;", "typedef vector<ld> vd;", "typedef vector<ll> vl;", "typedef vector<pi> vpi;", "typedef vector<pl> vpl;", "typedef vector<cd> vcd;", " ", "template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;", " ", "#define FOR(i, a, b) for (int i = (a); i < (b); i++)", "#define F0R(i, a) for (int i = 0; i < (a); i++)", "#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)", "#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)", "#define trav(a, x) for (auto& a : x)", " ", "#define mp make_pair", "#define pb push_back", "#define f first", "#define s second", "#define lb lower_bound", "#define ub upper_bound", " ", "#define sz(x) (int)x.size()", "#define beg(x) x.begin()", "#define en(x) x.end()", "#define all(x) beg(x), en(x)", "#define resz resize", " ", "const int MOD = 1000000007; // 998244353", "const ll INF = 1e18;", "const int MX = 100001;", "const ld PI = 4*atan((ld)1);", " ", "template<class T> void ckmin(T &a, T b) { a = min(a, b); }", "template<class T> void ckmax(T &a, T b) { a = max(a, b); }", " ", "namespace io {", "    // TYPE ID (StackOverflow)", "    ", "    template<class T> struct like_array : is_array<T>{};", "    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};", "    template<class T> struct like_array<vector<T>> : true_type{};", "    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }", " ", "    // I/O ", "    ", "    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }", "    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }", "    void setIO(string s = \"\") {", "        ios_base::sync_with_stdio(0); cin.tie(0);", "        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }", "    }", "    ", "    // INPUT ", "    ", "    template<class T> void re(T& x) { cin >> x; }", "    template<class Arg, class... Args> void re(Arg& first, Args&... rest);", "    void re(double& x) { string t; re(t); x = stod(t); }", "    void re(ld& x) { string t; re(t); x = stold(t); }", "    ", "    template<class T> void re(complex<T>& x);", "    template<class T1, class T2> void re(pair<T1,T2>& p);", "    template<class T> void re(vector<T>& a);", "    template<class T, size_t SZ> void re(array<T,SZ>& a);", "    ", "    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }", "    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }", "    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }", "    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }", "    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }", "    ", "    // OUTPUT ", "    ", "    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {", "        os << '{' << a.f << \", \" << a.s << '}'; return os;", "    }", "    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {", "        os << '{';", "        F0R(i,SZ) {", "            if (i) {", "                os << \", \";", "                if (is_like_array(a[i])) cout << \"\\n\";", "            }", "            os << a[i];", "        }", "        os << '}';", "        return os;", "    }", "    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {", "        return printArray(os,a,SZ);", "    }", "    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {", "        return printArray(os,a,sz(a));", "    }", "    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {", "        os << vector<T>(all(a)); return os;", "    }", "    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {", "        os << vector<pair<T1,T2>>(all(a)); return os;", "    }", "    ", "    template<class T> void pr(const T& x) { cout << x << '\\n'; }", "    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { ", "        cout << first << ' '; pr(rest...); ", "    }", "}", " ", "using namespace io;", " ", "namespace modOp {", "    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }", "    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }", "    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }", "    ", "    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }", "    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }", "    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }", "    ", "    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }", "    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }", "    ", "    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1", "        if (a == 0) return b == 1 ? 0 : -1;", "        int x = invGeneral(b%a,a); ", "        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;", "    }", "}", " ", "using namespace modOp;", " ", "int q, mx[MX], mn[MX];", " ", "int ran() {", "    return rand()^(rand()<<15);", "}", " ", "int main() {", "    setIO(); re(q);", "\tF0R(i,MX) mx[i] = -MOD, mn[i] = MOD;", "\tF0R(i,q) {", "\t    int t,l,r,k; re(t,l,r);", "\t    /*t = ran() % 2+1;", "\t    l = ran() % 100000+1;", "\t    r = ran() % 100000+1;", "\t    if (l > r) swap(l,r);", "\t    k = ran() % 200000-100000;*/", "\t    ", "\t    if (t == 1) {", "\t        re(k);", "    \t    if (k > 0) FOR(j,l,r) ckmin(mn[j],k);", "    \t    else FOR(j,l,r) ckmax(mx[j],k);", "\t    } else {", "\t        ll ans = 0;", "\t        FOR(j,l,r) ans += (mn[j]-mx[j])*(mx[j] != -MOD)*(mn[j] != MOD);", "\t        cout << ans << \"\\n\";", "\t    }", "\t}", "}", " ", "/* stuff you should look for", "    * int overflow, array bounds", "    * special cases (n=1?), set tle", "    * do smth instead of nothing and stay organized", "*/"]["#pragma GCC optimize (\"Ofast\")", "// #pragma GCC target (\"avx2\")", " ", "#include <bits/stdc++.h>", "#include <ext/pb_ds/tree_policy.hpp>", "#include <ext/pb_ds/assoc_container.hpp>", "#include <ext/rope>", " ", "using namespace std;", "using namespace __gnu_pbds;", "using namespace __gnu_cxx;", " ", "typedef long long ll;", "typedef long double ld;", "typedef complex<ld> cd;", " ", "typedef pair<int, int> pi;", "typedef pair<ll,ll> pl;", "typedef pair<ld,ld> pd;", " ", "typedef vector<int> vi;", "typedef vector<ld> vd;", "typedef vector<ll> vl;", "typedef vector<pi> vpi;", "typedef vector<pl> vpl;", "typedef vector<cd> vcd;", " ", "template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;", " ", "#define FOR(i, a, b) for (int i = (a); i < (b); i++)", "#define F0R(i, a) for (int i = 0; i < (a); i++)", "#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)", "#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)", "#define trav(a, x) for (auto& a : x)", " ", "#define mp make_pair", "#define pb push_back", "#define f first", "#define s second", "#define lb lower_bound", "#define ub upper_bound", " ", "#define sz(x) (int)x.size()", "#define beg(x) x.begin()", "#define en(x) x.end()", "#define all(x) beg(x), en(x)", "#define resz resize", " ", "const int MOD = 1000000007; // 998244353", "const ll INF = 1e18;", "const int MX = 100001;", "const ld PI = 4*atan((ld)1);", " ", "template<class T> void ckmin(T &a, T b) { a = min(a, b); }", "template<class T> void ckmax(T &a, T b) { a = max(a, b); }", " ", "namespace io {", "    // TYPE ID (StackOverflow)", "    ", "    template<class T> struct like_array : is_array<T>{};", "    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};", "    template<class T> struct like_array<vector<T>> : true_type{};", "    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }", " ", "    // I/O ", "    ", "    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }", "    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }", "    void setIO(string s = \"\") {", "        ios_base::sync_with_stdio(0); cin.tie(0);", "        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }", "    }", "    ", "    // INPUT ", "    ", "    template<class T> void re(T& x) { cin >> x; }", "    template<class Arg, class... Args> void re(Arg& first, Args&... rest);", "    void re(double& x) { string t; re(t); x = stod(t); }", "    void re(ld& x) { string t; re(t); x = stold(t); }", "    ", "    template<class T> void re(complex<T>& x);", "    template<class T1, class T2> void re(pair<T1,T2>& p);", "    template<class T> void re(vector<T>& a);", "    template<class T, size_t SZ> void re(array<T,SZ>& a);", "    ", "    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }", "    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }", "    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }", "    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }", "    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }", "    ", "    // OUTPUT ", "    ", "    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {", "        os << '{' << a.f << \", \" << a.s << '}'; return os;", "    }", "    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {", "        os << '{';", "        F0R(i,SZ) {", "            if (i) {", "                os << \", \";", "                if (is_like_array(a[i])) cout << \"\\n\";", "            }", "            os << a[i];", "        }", "        os << '}';", "        return os;", "    }", "    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {", "        return printArray(os,a,SZ);", "    }", "    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {", "        return printArray(os,a,sz(a));", "    }", "    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {", "        os << vector<T>(all(a)); return os;", "    }", "    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {", "        os << vector<pair<T1,T2>>(all(a)); return os;", "    }", "    ", "    template<class T> void pr(const T& x) { cout << x << '\\n'; }", "    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { ", "        cout << first << ' '; pr(rest...); ", "    }", "}", " ", "using namespace io;", " ", "namespace modOp {", "    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }", "    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }", "    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }", "    ", "    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }", "    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }", "    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }", "    ", "    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }", "    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }", "    ", "    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1", "        if (a == 0) return b == 1 ? 0 : -1;", "        int x = invGeneral(b%a,a); ", "        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;", "    }", "}", " ", "using namespace modOp;", " ", "int q, mx[MX], mn[MX];", " ", "int ran() {", "    return rand()^(rand()<<15);", "}", " ", "int main() {", "    setIO(); re(q);", "\tF0R(i,MX) mx[i] = -MOD, mn[i] = MOD;", "\tF0R(i,q) {", "\t    int t,l,r,k; re(t,l,r);", "\t    /*t = ran() % 2+1;", "\t    l = ran() % 100000+1;", "\t    r = ran() % 100000+1;", "\t    if (l > r) swap(l,r);", "\t    k = ran() % 200000-100000;*/", "\t    ", "\t    if (t == 1) {", "\t        re(k);", "    \t    if (k > 0) FOR(j,l,r) ckmin(mn[j],k);", "    \t    else FOR(j,l,r) ckmax(mx[j],k);", "\t    } else {", "\t        ll ans = 0;", "\t        FOR(j,l,r) ans += (mn[j]-mx[j])*(mx[j] != -MOD)*(mn[j] != MOD);", "\t        cout << ans << \"\\n\";", "\t    }", "\t}", "}", " ", "/* stuff you should look for", "    * int overflow, array bounds", "    * special cases (n=1?), set tle", "    * do smth instead of nothing and stay organized", "*/", ""]["#pragma GCC optimize (\"Ofast\", \"unroll-loops\")", "// #pragma GCC target (\"avx2\")", " ", "#include <bits/stdc++.h>", "#include <ext/pb_ds/tree_policy.hpp>", "#include <ext/pb_ds/assoc_container.hpp>", "#include <ext/rope>", " ", "using namespace std;", "using namespace __gnu_pbds;", "using namespace __gnu_cxx;", " ", "typedef long long ll;", "typedef long double ld;", "typedef complex<ld> cd;", " ", "typedef pair<int, int> pi;", "typedef pair<ll,ll> pl;", "typedef pair<ld,ld> pd;", " ", "typedef vector<int> vi;", "typedef vector<ld> vd;", "typedef vector<ll> vl;", "typedef vector<pi> vpi;", "typedef vector<pl> vpl;", "typedef vector<cd> vcd;", " ", "template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;", " ", "#define FOR(i, a, b) for (int i = (a); i < (b); i++)", "#define F0R(i, a) for (int i = 0; i < (a); i++)", "#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)", "#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)", "#define trav(a, x) for (auto& a : x)", " ", "#define mp make_pair", "#define pb push_back", "#define f first", "#define s second", "#define lb lower_bound", "#define ub upper_bound", " ", "#define sz(x) (int)x.size()", "#define beg(x) x.begin()", "#define en(x) x.end()", "#define all(x) beg(x), en(x)", "#define resz resize", " ", "const int MOD = 1000000007; // 998244353", "const ll INF = 1e18;", "const int MX = 100001;", "const ld PI = 4*atan((ld)1);", " ", "template<class T> void ckmin(T &a, T b) { a = min(a, b); }", "template<class T> void ckmax(T &a, T b) { a = max(a, b); }", " ", "namespace io {", "    // TYPE ID (StackOverflow)", "    ", "    template<class T> struct like_array : is_array<T>{};", "    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};", "    template<class T> struct like_array<vector<T>> : true_type{};", "    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }", " ", "    // I/O ", "    ", "    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }", "    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }", "    void setIO(string s = \"\") {", "        ios_base::sync_with_stdio(0); cin.tie(0);", "        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }", "    }", "    ", "    // INPUT ", "    ", "    template<class T> void re(T& x) { cin >> x; }", "    template<class Arg, class... Args> void re(Arg& first, Args&... rest);", "    void re(double& x) { string t; re(t); x = stod(t); }", "    void re(ld& x) { string t; re(t); x = stold(t); }", "    ", "    template<class T> void re(complex<T>& x);", "    template<class T1, class T2> void re(pair<T1,T2>& p);", "    template<class T> void re(vector<T>& a);", "    template<class T, size_t SZ> void re(array<T,SZ>& a);", "    ", "    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }", "    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }", "    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }", "    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }", "    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }", "    ", "    // OUTPUT ", "    ", "    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {", "        os << '{' << a.f << \", \" << a.s << '}'; return os;", "    }", "    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {", "        os << '{';", "        F0R(i,SZ) {", "            if (i) {", "                os << \", \";", "                if (is_like_array(a[i])) cout << \"\\n\";", "            }", "            os << a[i];", "        }", "        os << '}';", "        return os;", "    }", "    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {", "        return printArray(os,a,SZ);", "    }", "    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {", "        return printArray(os,a,sz(a));", "    }", "    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {", "        os << vector<T>(all(a)); return os;", "    }", "    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {", "        os << vector<pair<T1,T2>>(all(a)); return os;", "    }", "    ", "    template<class T> void pr(const T& x) { cout << x << '\\n'; }", "    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { ", "        cout << first << ' '; pr(rest...); ", "    }", "}", " ", "using namespace io;", " ", "namespace modOp {", "    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }", "    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }", "    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }", "    ", "    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }", "    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }", "    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }", "    ", "    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }", "    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }", "    ", "    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1", "        if (a == 0) return b == 1 ? 0 : -1;", "        int x = invGeneral(b%a,a); ", "        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;", "    }", "}", " ", "using namespace modOp;", " ", "int q, mx[MX], mn[MX];", " ", "int ran() {", "    return rand()^(rand()<<15);", "}", " ", "int main() {", "    setIO(); re(q);", "\tF0R(i,MX) mx[i] = -MOD, mn[i] = MOD;", "\tF0R(i,q) {", "\t    int t,l,r,k; re(t,l,r);", "\t    /*t = ran() % 2+1;", "\t    l = ran() % 100000+1;", "\t    r = ran() % 100000+1;", "\t    if (l > r) swap(l,r);", "\t    k = ran() % 200000-100000;*/", "\t    ", "\t    if (t == 1) {", "\t        re(k);", "    \t    if (k > 0) FOR(j,l,r) ckmin(mn[j],k);", "    \t    else FOR(j,l,r) ckmax(mx[j],k);", "\t    } else {", "\t        ll ans = 0;", "\t        FOR(j,l,r) ans += (mn[j]-mx[j])*(mx[j] != -MOD)*(mn[j] != MOD);", "\t        cout << ans << \"\\n\";", "\t    }", "\t}", "}", " ", "/* stuff you should look for", "    * int overflow, array bounds", "    * special cases (n=1?), set tle", "    * do smth instead of nothing and stay organized", "*/", ""]["#include <bits/stdc++.h>", "using namespace std;", " ", "typedef long long ll;", "typedef long double ld;", "typedef double db; ", "typedef string str; ", "", "typedef pair<int,int> pi;", "typedef pair<ll,ll> pl; ", "typedef pair<db,db> pd; ", "", "typedef vector<int> vi; ", "typedef vector<bool> vb; ", "typedef vector<ll> vl; ", "typedef vector<db> vd; ", "typedef vector<str> vs; ", "typedef vector<pi> vpi;", "typedef vector<pl> vpl; ", "typedef vector<pd> vpd; ", "", "#define mp make_pair", "#define f first", "#define s second", "#define sz(x) (int)(x).size()", "#define all(x) begin(x), end(x)", "#define rall(x) (x).rbegin(), (x).rend() ", "#define sor(x) sort(all(x)) ", "#define rsz resize", "#define ins insert ", "#define ft front() ", "#define bk back()", "#define pf push_front ", "#define pb push_back", "#define eb emplace_back ", "#define lb lower_bound ", "#define ub upper_bound ", "", "#define FOR(i,a,b) for (int i = (a); i < (b); ++i)", "#define F0R(i,a) FOR(i,0,a)", "#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)", "#define R0F(i,a) ROF(i,0,a)", "#define trav(a,x) for (auto& a: x)", "", "const int MOD = 1e9+7; // 998244353;", "const int MX = 2e5+5; ", "const ll INF = 1e18; ", "const ld PI = acos((ld)-1);", "const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; ", "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ", "", "template<class T> bool ckmin(T& a, const T& b) { ", "\treturn b < a ? a = b, 1 : 0; }", "template<class T> bool ckmax(T& a, const T& b) { ", "\treturn a < b ? a = b, 1 : 0; } ", "constexpr int pct(int x) { return __builtin_popcount(x); } ", "constexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) ", "ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up", "ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down", "ll half(ll x) { return fdiv(x,2); }", "", "template<class T, class U> T fstTrue(T lo, T hi, U f) { ", "\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi", "\thi ++; assert(lo <= hi); // assuming f is increasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi);", "\t\tf(mid) ? hi = mid : lo = mid+1; ", "\t} ", "\treturn lo;", "}", "template<class T, class U> T lstTrue(T lo, T hi, U f) {", "\tlo --; assert(lo <= hi); // assuming f is decreasing", "\twhile (lo < hi) { // find first index such that f is true ", "\t\tT mid = half(lo+hi+1);", "\t\tf(mid) ? lo = mid : hi = mid-1;", "\t} ", "\treturn lo;", "}", "template<class T> void remDup(vector<T>& v) { ", "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }", "", "// INPUT", "template<class A> void re(complex<A>& c);", "template<class A, class B> void re(pair<A,B>& p);", "template<class A> void re(vector<A>& v);", "template<class A, size_t SZ> void re(array<A,SZ>& a);", "", "template<class T> void re(T& x) { cin >> x; }", "void re(db& d) { str t; re(t); d = stod(t); }", "void re(ld& d) { str t; re(t); d = stold(t); }", "template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }", "", "template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }", "template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }", "template<class A> void re(vector<A>& x) { trav(a,x) re(a); }", "template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }", "", "// TO_STRING", "#define ts to_string", "str ts(char c) { return str(1,c); }", "str ts(const char* s) { return (str)s; }", "str ts(str s) { return s; }", "str ts(bool b) { ", "\t#ifdef LOCAL", "\t\treturn b ? \"true\" : \"false\"; ", "\t#else ", "\t\treturn ts((int)b);", "\t#endif", "}", "template<class A> str ts(complex<A> c) { ", "\tstringstream ss; ss << c; return ss.str(); }", "str ts(vector<bool> v) {", "\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);", "\tres += \"}\"; return res; }", "template<size_t SZ> str ts(bitset<SZ> b) {", "\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);", "\treturn res; }", "template<class A, class B> str ts(pair<A,B> p);", "template<class T> str ts(T v) { // containers with begin(), end()", "\t#ifdef LOCAL", "\t\tbool fst = 1; str res = \"{\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \", \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\tres += \"}\"; return res;", "\t#else", "\t\tbool fst = 1; str res = \"\";", "\t\tfor (const auto& x: v) {", "\t\t\tif (!fst) res += \" \";", "\t\t\tfst = 0; res += ts(x);", "\t\t}", "\t\treturn res;", "", "\t#endif", "}", "template<class A, class B> str ts(pair<A,B> p) {", "\t#ifdef LOCAL", "\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; ", "\t#else", "\t\treturn ts(p.f)+\" \"+ts(p.s);", "\t#endif", "}", "", "// OUTPUT", "template<class A> void pr(A x) { cout << ts(x); }", "template<class H, class... T> void pr(const H& h, const T&... t) { ", "\tpr(h); pr(t...); }", "void ps() { pr(\"\\n\"); } // print w/ spaces", "template<class H, class... T> void ps(const H& h, const T&... t) { ", "\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }", "", "// DEBUG", "void DBG() { cerr << \"]\" << endl; }", "template<class H, class... T> void DBG(H h, T... t) {", "\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";", "\tDBG(t...); }", "#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert", "\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)", "\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\", "\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);", "#else", "\t#define dbg(...) 0", "\t#define chk(...) 0", "#endif", "", "// FILE I/O", "void setIn(str s) { freopen(s.c_str(),\"r\",stdin); }", "void setOut(str s) { freopen(s.c_str(),\"w\",stdout); }", "void unsyncIO() { cin.tie(0)->sync_with_stdio(0); }", "void setIO(str s = \"\") {", "\tunsyncIO();", "\t// cin.exceptions(cin.failbit); ", "\t// throws exception when do smth illegal", "\t// ex. try to read letter into int", "\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO", "}", "", "int n;", "int a[MX];", "vi pal[MX];", "int p[MX], q[MX], num[MX];", "", "void getPals(int pos) {", "\tpal[pos].clear(); if (pos == 1) return;", "\tif (a[pos] == a[pos-1]) pal[pos].pb(2);", "\ttrav(x,pal[pos-1]) if (a[pos] == a[pos-x-1]) pal[pos].pb(x+2);", "}", "", "bool checkPal(int L, int R) {", "\ttrav(t,pal[R]) if (t == R-L+1) return 1;", "\treturn 0;", "}", "", "int xyx;", "int pos = 0;", "", "int query() {", "\tint res = xyx+num[pos];", "\tint cur = pos;", "\twhile (p[cur] && q[pos] <= cur-p[cur]/2) {", "\t\tcur -= p[cur]/2;", "\t\t++ res;", "\t}", "\treturn res;", "}", "", "int main() {", "\tsetIO(); re(n);", "\tq[0] = 1;", "\tF0R(i,n) {", "\t\tpos ++; re(a[pos]);", "\t\tgetPals(pos);", "\t\t// dbg(pos,pal[pos]);", "\t\tbool done = 0;", "\t\tif (sz(pal[pos])) {", "\t\t\tint len = pal[pos].ft;", "\t\t\tif (checkPal(pos-len/2-len+1,pos-len/2)) {", "\t\t\t\tpos -= len; xyx += 2;", "\t\t\t\tdone = 1;", "\t\t\t}", "\t\t}", "\t\tif (!done) {", "\t\t\tp[pos] = sz(pal[pos]) ? pal[pos][0] : 0; // smallest pal", "\t\t\tq[pos] = q[pos-1];", "\t\t\tnum[pos] = num[pos-1];", "\t\t\t// dbg(\"HUH\",pos,num[pos],q[pos],pos);", "\t\t\tif (checkPal(q[pos],pos)) {", "\t\t\t\tq[pos] = (q[pos]+pos+1)/2;", "\t\t\t\tnum[pos] ++;", "\t\t\t}", "\t\t}", "\t\tpr(query(),' ');", "\t}", "\t// you should actually read the stuff at the bottom", "}", "", "/* stuff you should look for", "\t* int overflow, array bounds", "\t* special cases (n=1?)", "\t* do smth instead of nothing and stay organized", "\t* WRITE STUFF DOWN", "*/", "", ""]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));", "// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);", "", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<unordered_map>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-11;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 11100000;", "const int UF_SIZE = 3100000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tinline long long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\tif(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "char in[110];", "int dp[80][80][80][2];", "int n;", "int calc(int a,int b,int c,int d){", "\tint ret=0;", "\tfor(int i=0;i<n;i++){", "\t\tif(in[i]=='K'){", "\t\t\tif(a==0){", "\t\t\t\tif(d==0)return ret;", "\t\t\t\tret++;", "\t\t\t}", "\t\t\telse a--;", "\t\t}else if(in[i]=='V'){", "\t\t\tif(c==0){", "\t\t\t\tif(d==2)return ret;", "\t\t\t\tret++;", "\t\t\t}", "\t\t\telse c--;", "\t\t}else{", "\t\t\tif(b==0){", "\t\t\t\tif(d==1)return ret;", "\t\t\t\tret++;", "\t\t\t}", "\t\t\telse b--;", "\t\t}", "\t}", "\treturn mod;", "}", "int main(){", "\tint a;scanf(\"%d\",&a);n=a;", "\tscanf(\"%s\",in);", "\tint V=0;", "\tint K=0;", "\tfor(int i=0;i<a;i++){", "\t\tif(in[i]=='K')K++;", "\t\tif(in[i]=='V')V++;", "\t}", "\tfor(int i=0;i<80;i++)for(int j=0;j<80;j++)for(int k=0;k<80;k++)for(int l=0;l<2;l++)dp[i][j][k][l]=mod;", "\tdp[0][0][0][0]=0;", "\tfor(int i=0;i<a;i++){", "\t\tfor(int j=0;j<=K;j++){", "\t\t\tfor(int k=0;k<=a-K-V;k++){", "\t\t\t\tfor(int l=0;l<2;l++){", "\t\t\t\t\tif(dp[i][j][k][l]==mod)continue;", "\t\t\t\t\tif(l==0&&j<K){", "\t\t\t\t\t\tdp[i+1][j+1][k][0]=min(dp[i+1][j+1][k][0],dp[i][j][k][l]+calc(j,k,i-j-k,0));", "\t\t\t\t\t}", "\t\t\t\t\tif(k<a-K-V){", "\t\t\t\t\t\tdp[i+1][j][k+1][0]=min(dp[i+1][j][k+1][0],dp[i][j][k][l]+calc(j,k,i-j-k,1));", "\t\t\t\t\t}", "\t\t\t\t\tif(i-j-k<V){", "\t\t\t\t\t\tdp[i+1][j][k][1]=min(dp[i+1][j][k][1],dp[i][j][k][l]+calc(j,k,i-j-k,2));", "\t\t\t\t\t}", "\t\t\t\t}", "\t\t\t}", "\t\t}", "\t}", "\tint ret=min(dp[a][K][a-K-V][0],dp[a][K][a-K-V][1]);", "\tprintf(\"%d\\n\",ret);", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));", "// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);", "", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<unordered_map>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-11;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 11100000;", "const int UF_SIZE = 3100000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tinline long long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\tif(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int dp[210000][6];", "vector<int>g[210000];", "long long ret;", "int sz[210000];", "int n;", "int m;", "void dfs(int a,int b){", "\tsz[a]=1;", "\tdp[a][0]=1;", "\tfor(int i=0;i<g[a].size();i++){", "\t\tif(b==g[a][i])continue;", "\t\tdfs(g[a][i],a);", "\t\tfor(int j=0;j<m;j++){", "\t\t\tfor(int k=0;k<m;k++){", "\t\t\t\tret+=(long long)dp[a][k]*dp[g[a][i]][j]*((k+(j+1)%m+m-1)/m);", "\t\t\t}", "\t\t}", "\t\tfor(int j=0;j<m;j++){", "\t\t\tdp[a][(j+1)%m]+=dp[g[a][i]][j];", "\t\t\tif(j==m-1){", "\t\t\t\tret+=(long long)dp[g[a][i]][j]*(n-sz[g[a][i]]);", "\t\t\t}", "\t\t}", "\t\tsz[a]+=sz[g[a][i]];", "\t}", "", "}", "int main(){", "\tint a,b;scanf(\"%d%d\",&a,&b);n=a;", "\tm=b;", "\tfor(int i=0;i<a-1;i++){", "\t\tint p,q;scanf(\"%d%d\",&p,&q);", "\t\tp--;q--;", "\t\tg[p].push_back(q);", "\t\tg[q].push_back(p);", "\t}", "\tdfs(0,-1);", "\t// ret/=2;", "\tprintf(\"%lld\\n\",ret);", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));", "// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);", "", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<unordered_map>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-11;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 11100000;", "const int UF_SIZE = 3100000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tinline long long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\tif(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "char in[110];", "int t[110];", "int main(){", "\tint a,b;scanf(\"%d%d\",&a,&b);", "\tint f=-1;", "\tfor(int i=0;i<a-b+1;i++){", "\t\tscanf(\"%s\",in+i);", "", "\t}", "\tfor(int i=0;i<b-1;i++){", "\t\tt[i]=i;", "\t}", "\tfor(int i=b-1;i<a;i++){", "\t\tif(in[i-b+1]=='Y'){", "\t\t\tt[i]=i;", "\t\t}else{", "\t\t\tt[i]=t[i-b+1];", "\t\t}", "\t}", "\tfor(int i=0;i<a;i++){", "\t\tif(i)printf(\" \");", "\t\tif(t[i]<26)printf(\"%c\",t[i]+'A');", "\t\telse printf(\"A%c\",'a'+(t[i]-26));", "\t}", "\tprintf(\"\\n\");", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));", "// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);", " ", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<unordered_map>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const long double EPS=1e-9;", "const long double INF=1e+10;", "const long double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 3100000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\t// if(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int v[10100][1010];", "int ijk[10100][1010];", "int p[10100];", "queue<pair<int,pair<int,int> > >Q[1100];", "int main(){", "\tint a,b;scanf(\"%d%d\",&a,&b);", "\tfor(int i=0;i<b;i++){", "\t\tscanf(\"%d\",p+i);", "\t}", "\tint G,R;scanf(\"%d%d\",&G,&R);", "\tstd::sort(p,p+b);", "\tfor(int i=0;i<b;i++)for(int j=0;j<=G;j++){", "\t\tijk[i][j]=mod*2;", "\t}", "\tijk[0][0]=0;", "\t// priority_queue<pair<int,pair<int,int> > > Q;", "\tQ[0].push(make_pair(0,make_pair(0,0)));", "\tint D=1010;", "\twhile(1){", "\t\tbool chg=false;", "\t\tfor(int i=0;i<D;i++){", "\t\t\twhile(Q[i].size()){", "\t\t\t\tint cost=-Q[i].front().first;", "\t\t\t\tint at=Q[i].front().second.first;", "\t\t\t\tint ind=Q[i].front().second.second;", "\t\t\t\tQ[i].pop();", "\t\t\t\tif(v[at][ind])continue;", "\t\t\t\tv[at][ind]=1;", " ", "\t\t\t\tif(ind==G&&v[at][0]==0&&ijk[at][0]>cost+R){", "\t\t\t\t\tijk[at][0]=cost+R;", "\t\t\t\t\tchg=true;", "\t\t\t\t\tQ[(cost+R)%D].push(make_pair(-cost-R,make_pair(at,0)));", "\t\t\t\t}", "\t\t\t\tif(at){", "\t\t\t\t\tint T=p[at]-p[at-1];", "\t\t\t\t\tint F=ind+T;", "\t\t\t\t\tif(F<=G&&v[at-1][F]==0&&ijk[at-1][F]>cost+T){", "\t\t\t\t\t\tijk[at-1][F]=cost+T;", "\t\t\t\t\t\tchg=true;", "\t\t\t\t\t\tQ[(cost+T)%D].push(make_pair(-ijk[at-1][F],make_pair(at-1,F)));", "\t\t\t\t\t}", "\t\t\t\t}", "\t\t\t\tif(at+1<b){", "\t\t\t\t\tint T=p[at+1]-p[at];", "\t\t\t\t\tint F=ind+T;", "\t\t\t\t\tif(F<=G&&v[at+1][F]==0&&ijk[at+1][F]>cost+T){", "\t\t\t\t\t\tijk[at+1][F]=cost+T;", "\t\t\t\t\t\tchg=true;", "\t\t\t\t\t\tQ[(cost+T)%D].push(make_pair(-ijk[at+1][F],make_pair(at+1,F)));", "\t\t\t\t\t}", "\t\t\t\t}", "\t\t\t}\t\t\t", "\t\t}", "\t\tif(!chg){", "\t\t\tbreak;", "\t\t}", "\t}", " ", "\tint ret=mod*2;", "\tfor(int i=0;i<=G;i++){", "\t\tret=min(ret,ijk[b-1][i]);", "\t}", "\tif(ret==mod*2)ret=-1;", "\tprintf(\"%d\\n\",ret);", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));", "// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);", " ", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<unordered_map>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const long double EPS=1e-9;", "const long double INF=1e+10;", "const long double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 3100000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\t// if(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int v[10100][1010];", "int ijk[10100][1010];", "int p[10100];", "queue<pair<int,pair<int,int> > >Q[2100];", "int main(){", "\tint a,b;scanf(\"%d%d\",&a,&b);", "\tfor(int i=0;i<b;i++){", "\t\tscanf(\"%d\",p+i);", "\t}", "\tint G,R;scanf(\"%d%d\",&G,&R);", "\tstd::sort(p,p+b);", "\tfor(int i=0;i<b;i++)for(int j=0;j<=G;j++){", "\t\tijk[i][j]=mod*2;", "\t}", "\tijk[0][0]=0;", "\t// priority_queue<pair<int,pair<int,int> > > Q;", "\tQ[0].push(make_pair(0,make_pair(0,0)));", "\tint D=2020;", "\twhile(1){", "\t\tbool chg=false;", "\t\tfor(int i=0;i<D;i++){", "\t\t\tif(Q[i].size())chg=true;", "\t\t}", "\t\tif(!chg){", "\t\t\tbreak;", "\t\t}", "\t\tfor(int i=0;i<D;i++){", "\t\t\twhile(Q[i].size()){", "\t\t\t\tint cost=-Q[i].front().first;", "\t\t\t\tint at=Q[i].front().second.first;", "\t\t\t\tint ind=Q[i].front().second.second;", "\t\t\t\tQ[i].pop();", "\t\t\t\tif(v[at][ind])continue;", "\t\t\t\tv[at][ind]=1;", " ", "\t\t\t\tif(ind==G&&v[at][0]==0&&ijk[at][0]>cost+R){", "\t\t\t\t\tijk[at][0]=cost+R;", "\t\t\t\t\tQ[(cost+R)%D].push(make_pair(-cost-R,make_pair(at,0)));", "\t\t\t\t}", "\t\t\t\tif(at){", "\t\t\t\t\tint T=p[at]-p[at-1];", "\t\t\t\t\tint F=ind+T;", "\t\t\t\t\tif(F<=G&&v[at-1][F]==0&&ijk[at-1][F]>cost+T){", "\t\t\t\t\t\tijk[at-1][F]=cost+T;", "\t\t\t\t\t\tQ[(cost+T)%D].push(make_pair(-ijk[at-1][F],make_pair(at-1,F)));", "\t\t\t\t\t}", "\t\t\t\t}", "\t\t\t\tif(at+1<b){", "\t\t\t\t\tint T=p[at+1]-p[at];", "\t\t\t\t\tint F=ind+T;", "\t\t\t\t\tif(F<=G&&v[at+1][F]==0&&ijk[at+1][F]>cost+T){", "\t\t\t\t\t\tijk[at+1][F]=cost+T;", "\t\t\t\t\t\tQ[(cost+T)%D].push(make_pair(-ijk[at+1][F],make_pair(at+1,F)));", "\t\t\t\t\t}", "\t\t\t\t}", "\t\t\t}\t\t\t", "\t\t}", "\t\t", "\t}", " ", "\tint ret=mod*2;", "\tfor(int i=0;i<=G;i++){", "\t\tret=min(ret,ijk[b-1][i]);", "\t}", "\tif(ret==mod*2)ret=-1;", "\tprintf(\"%d\\n\",ret);", "}"]["#pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "#pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "#pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));", "// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);", " ", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<unordered_map>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const long double EPS=1e-9;", "const long double INF=1e+10;", "const long double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 3100000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\t// if(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int v[10100][1010];", "int ijk[10100][1010];", "int p[10100];", "int main(){", "\tint a,b;scanf(\"%d%d\",&a,&b);", "\tfor(int i=0;i<b;i++){", "\t\tscanf(\"%d\",p+i);", "\t}", "\tint G,R;scanf(\"%d%d\",&G,&R);", "\tstd::sort(p,p+b);", "\tfor(int i=0;i<b;i++)for(int j=0;j<=G;j++){", "\t\tijk[i][j]=mod*2;", "\t}", "\tijk[0][0]=0;", "\tpriority_queue<long long> Q;", "\tQ.push(0LL);", "\twhile(Q.size()){", "\t\tint cost=(-Q.top())>>30;", "\t\tint at=(-Q.top())&((1<<30)-1);", "\t\tint ind=cost%(G+R);", "\t\tQ.pop();", "\t\tif(v[at][ind])continue;", "\t\tv[at][ind]=1;", " ", "\t\tif(ind==G&&v[at][0]==0&&ijk[at][0]>cost+R){", "\t\t\tijk[at][0]=cost+R;", "\t\t\tQ.push(-((long long)ijk[at][0]<<30)-at);", "\t\t}", "\t\tif(at){", "\t\t\tint T=p[at]-p[at-1];", "\t\t\tint F=ind+T;", "\t\t\tif(F<=G&&v[at-1][F]==0&&ijk[at-1][F]>cost+T){", "\t\t\t\tijk[at-1][F]=cost+T;", "\t\t\t\tQ.push(-((long long)ijk[at-1][F]<<30)-(at-1));", "\t\t\t\t", "\t\t\t}", "\t\t}", "\t\tif(at+1<b){", "\t\t\tint T=p[at+1]-p[at];", "\t\t\tint F=ind+T;", "\t\t\tif(F<=G&&v[at+1][F]==0&&ijk[at+1][F]>cost+T){", "\t\t\t\tijk[at+1][F]=cost+T;", "\t\t\t\tQ.push(-((long long)ijk[at+1][F]<<30)-(at+1));", "\t\t\t}", "\t\t}", "\t}", "\tint ret=mod*2;", "\tfor(int i=0;i<=G;i++){", "\t\tret=min(ret,ijk[b-1][i]);", "\t}", "\tif(ret==mod*2)ret=-1;", "\tprintf(\"%d\\n\",ret);", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));", "// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);", " ", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<unordered_map>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const long double EPS=1e-9;", "const long double INF=1e+10;", "const long double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 3100000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\t// if(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int v[10100][1010];", "int ijk[10100][1010];", "int p[10100];", "int main(){", "\tint a,b;scanf(\"%d%d\",&a,&b);", "\tfor(int i=0;i<b;i++){", "\t\tscanf(\"%d\",p+i);", "\t}", "\tint G,R;scanf(\"%d%d\",&G,&R);", "\tstd::sort(p,p+b);", "\tfor(int i=0;i<b;i++)for(int j=0;j<=G;j++){", "\t\tijk[i][j]=mod*2;", "\t}", "\tijk[0][0]=0;", "\tpriority_queue<long long> Q;", "\tQ.push(0LL);", "\twhile(Q.size()){", "\t\tint cost=(-Q.top())>>30;", "\t\tint at=(-Q.top())&((1<<30)-1);", "\t\tint ind=cost%(G+R);", "\t\tQ.pop();", "\t\tif(v[at][ind])continue;", "\t\tv[at][ind]=1;", " ", "\t\tif(ind==G&&v[at][0]==0&&ijk[at][0]>cost+R){", "\t\t\tijk[at][0]=cost+R;", "\t\t\tQ.push(-((long long)ijk[at][0]<<30)-at);", "\t\t}", "\t\tif(at){", "\t\t\tint T=p[at]-p[at-1];", "\t\t\tint F=ind+T;", "\t\t\tif(F<=G&&v[at-1][F]==0&&ijk[at-1][F]>cost+T){", "\t\t\t\tijk[at-1][F]=cost+T;", "\t\t\t\tQ.push(-((long long)ijk[at-1][F]<<30)-(at-1));", "\t\t\t\t", "\t\t\t}", "\t\t}", "\t\tif(at+1<b){", "\t\t\tint T=p[at+1]-p[at];", "\t\t\tint F=ind+T;", "\t\t\tif(F<=G&&v[at+1][F]==0&&ijk[at+1][F]>cost+T){", "\t\t\t\tijk[at+1][F]=cost+T;", "\t\t\t\tQ.push(-((long long)ijk[at+1][F]<<30)-(at+1));", "\t\t\t}", "\t\t}", "\t}", "\tint ret=mod*2;", "\tfor(int i=0;i<=G;i++){", "\t\tret=min(ret,ijk[b-1][i]);", "\t}", "\tif(ret==mod*2)ret=-1;", "\tprintf(\"%d\\n\",ret);", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));", "// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);", "", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<unordered_map>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const long double EPS=1e-9;", "const long double INF=1e+10;", "const long double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 3100000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\t// if(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "vector<int>g[110000];", "vector<pair<int,int> > ans;", "int M;", "void dfs(int a,int b,int L){", "\tans.push_back(make_pair(a,L));", "\tint deg=0;", "\tfor(int i=0;i<g[a].size();i++){", "\t\tif(b==g[a][i])continue;", "\t\tdeg++;", "\t}", "\tif(deg==0){", "\t\tans.push_back(make_pair(a,L-1));", "\t\treturn;", "\t}", "\tbool flag=false;", "\tfor(int i=0;i<g[a].size();i++){", "\t\tif(b==g[a][i])continue;", "\t\tif(L==M){", "\t\t\tL-=deg+1;", "\t\t\tflag=true;", "\t\t\tans.push_back(make_pair(a,L));", "\t\t}", "\t\tdfs(g[a][i],a,L+1);", "\t\tans.push_back(make_pair(a,L+1));", "\t\tL++;", "\t}", "\tif(!flag&&a){", "\t\tL-=deg+1;", "\t\tans.push_back(make_pair(a,L));", "\t}", "}", "int main(){", "\tint a;scanf(\"%d\",&a);", "\tif(a==1){", "\t\tprintf(\"1\\n\");", "\t\tprintf(\"1 0\\n\");", "\t\treturn 0;", "\t}", "\tfor(int i=0;i<a-1;i++){", "\t\tint p,q;scanf(\"%d%d\",&p,&q);", "\t\tp--;q--;", "\t\tg[p].push_back(q);", "\t\tg[q].push_back(p);", "\t}", "\tfor(int i=0;i<a;i++){", "\t\tM=max(M,(int)(g[i].size()));", "\t}", "\tdfs(0,-1,0);", "\tprintf(\"%d\\n\",(int)(ans.size()));", "\tfor(int i=0;i<ans.size();i++){", "\t\tprintf(\"%d %d\\n\",ans[i].first+1,ans[i].second);", "\t}", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));", "// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);", "", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<unordered_map>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const long double EPS=1e-9;", "const long double INF=1e+10;", "const long double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 3100000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\t// if(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int v[10100][1010];", "int ijk[10100][1010];", "int p[10100];", "int main(){", "\tint a,b;scanf(\"%d%d\",&a,&b);", "\tfor(int i=0;i<b;i++){", "\t\tscanf(\"%d\",p+i);", "\t}", "\tint G,R;scanf(\"%d%d\",&G,&R);", "\tstd::sort(p,p+b);", "\tfor(int i=0;i<b;i++)for(int j=0;j<=G;j++){", "\t\tijk[i][j]=mod*2;", "\t}", "\tijk[0][0]=0;", "\tpriority_queue<pair<int,int > > Q;", "\tQ.push(make_pair(0,0));", "\twhile(Q.size()){", "\t\tint cost=-Q.top().first;", "\t\tint at=Q.top().second;", "\t\tint ind=cost%(G+R);", "\t\tQ.pop();", "\t\tif(v[at][ind])continue;", "\t\tv[at][ind]=1;", " ", "\t\tif(ind==G&&v[at][0]==0&&ijk[at][0]>cost+R){", "\t\t\tijk[at][0]=cost+R;", "\t\t\tQ.push(make_pair(-cost-R,at));", "\t\t}", "\t\tif(at){", "\t\t\tint T=p[at]-p[at-1];", "\t\t\tint F=ind+T;", "\t\t\tif(F<=G&&v[at-1][F]==0&&ijk[at-1][F]>cost+T){", "\t\t\t\tijk[at-1][F]=cost+T;", "\t\t\t\tQ.push(make_pair(-ijk[at-1][F],at-1));", "\t\t\t}", "\t\t}", "\t\tif(at+1<b){", "\t\t\tint T=p[at+1]-p[at];", "\t\t\tint F=ind+T;", "\t\t\tif(F<=G&&v[at+1][F]==0&&ijk[at+1][F]>cost+T){", "\t\t\t\tijk[at+1][F]=cost+T;", "\t\t\t\tQ.push(make_pair(-ijk[at+1][F],at+1));", "\t\t\t}", "\t\t}", "\t}", "\tint ret=mod*2;", "\tfor(int i=0;i<=G;i++){", "\t\tret=min(ret,ijk[b-1][i]);", "\t}", "\tif(ret==mod*2)ret=-1;", "\tprintf(\"%d\\n\",ret);", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));", "// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);", "", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<unordered_map>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const long double EPS=1e-9;", "const long double INF=1e+10;", "const long double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 3100000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\t// if(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int p[110000];", "int rev[110000];", "int main(){", "\tint T;scanf(\"%d\",&T);", "\twhile(T--){", "\t\tint a;scanf(\"%d\",&a);", "\t\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);", "\t\tfor(int i=0;i<a;i++)p[i]--;", "\t\tfor(int i=0;i<a;i++)rev[p[i]]=i;", "", "\t\tint cur=0;", "\t\tint L=a;", "\t\twhile(cur<a){", "\t\t\tint fi=rev[cur];", "\t\t\tint at=rev[cur];", "\t\t\twhile(at<L){", "\t\t\t\tif(cur!=p[at]){", "\t\t\t\t\tprintf(\"No\\n\");goto END;", "\t\t\t\t}", "\t\t\t\tcur++;", "\t\t\t\tat++;", "\t\t\t}", "\t\t\tL=fi;", "\t\t}", "\t\tprintf(\"Yes\\n\");", "\t\tEND:;", "\t}", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));", "// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);", "", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<unordered_map>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const long double EPS=1e-9;", "const long double INF=1e+10;", "const long double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 3100000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\t// if(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "char in[2100][10];", "int dp[2100][2100];", "char pat[10][10]={\"1110111\", \"0010010\", \"1011101\", \"1011011\", \"0111010\", \"1101011\", \"1101111\", \"1010010\", \"1111111\", \"1111011\" };", "int cost[2100][10];", "int main(){", "\tint a,b;scanf(\"%d%d\",&a,&b);", "\tfor(int i=0;i<a;i++){", "\t\tscanf(\"%s\",in[i]);", "\t\tfor(int j=0;j<10;j++){", "\t\t\tbool ng=false;", "\t\t\tfor(int k=0;k<7;k++){", "\t\t\t\tif(pat[j][k]=='0'&&in[i][k]=='1'){", "\t\t\t\t\tng=true;", "\t\t\t\t}", "\t\t\t\tif(pat[j][k]=='1'&&in[i][k]=='0'){", "\t\t\t\t\tcost[i][j]++;", "\t\t\t\t}", "\t\t\t}", "\t\t\tif(ng)cost[i][j]=mod;", "\t\t}", "\t}", "\tdp[0][0]=1;", "\tfor(int i=0;i<a;i++){", "\t\tfor(int j=0;j<=b;j++){", "\t\t\tif(dp[i][j]==0)continue;", "\t\t\tfor(int k=0;k<10;k++){", "\t\t\t\tif(j+cost[a-1-i][k]>b){", "\t\t\t\t\tcontinue;", "\t\t\t\t}", "\t\t\t\tdp[i+1][j+cost[a-1-i][k]]=1;", "\t\t\t}", "\t\t}", "\t}", "\tint rem=b;", "\tfor(int i=0;i<a;i++){", "\t\tbool ok=false;", "\t\tfor(int j=9;j>=0;j--){", "\t\t\tif(rem-cost[i][j]>=0&&dp[a-i-1][rem-cost[i][j]]){", "\t\t\t\tok=true;", "\t\t\t\tprintf(\"%d\",j);", "\t\t\t\trem-=cost[i][j];", "\t\t\t\tbreak;", "\t\t\t}", "\t\t}", "\t\tif(!ok){", "\t\t\tprintf(\"-1\\n\");return 0;", "\t\t}", "\t}", "\tprintf(\"\\n\");", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 210000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\tif(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "char in[210000];", "const int SQ=400;", "vector<int>one;", "int M[91000000];", "int main(){", "\tscanf(\"%s\",in);", "\tint n=strlen(in);", "\tlong long ret=0;", "\tint ren=0;", "\tfor(int i=0;i<n;i++){", "\t\tif(in[i]=='1'){", "\t\t\tren++;", "\t\t\tret+=ren;", "\t\t\tone.push_back(i);", "\t\t}else ren=0;", "\t}", "\tone.push_back(n);", "\tfor(int i=1;i<=SQ;i++){", "\t\tint cur=1000000;", "\t\tM[cur]++;", "\t\tfor(int j=0;j<n;j++){", "\t\t\tif(in[j]=='1'){", "\t\t\t\tcur+=i;", "\t\t\t}else cur--;", "\t\t\tret+=M[cur];", "\t\t\tM[cur]++;", "\t\t}", "\t\tcur=1000000;", "\t\tM[cur]--;", "\t\tfor(int j=0;j<n;j++){", "\t\t\tif(in[j]=='1'){", "\t\t\t\tcur+=i;", "\t\t\t}else cur--;", "\t\t\tM[cur]--;", "\t\t}", "\t}", "\tfor(int i=0;i<n;i++){", "\t\tint at=lower_bound(one.begin(),one.end(),i)-one.begin();", "\t\tlong long zero=one[at]-i;", "\t\tint o=0;", "\t\tfor(int j=at;j<one.size()-1;j++){", "\t\t\to++;", "\t\t\tif(i+(SQ+1)*o>n)break;", "\t\t\tlong long L=max(zero,(long long)SQ*o+1)-1;", "\t\t\tlong long R=zero+one[j+1]-one[j]-1;", "\t\t\tif(L<=R){", "\t\t\t\tret+=R/o;", "\t\t\t\tret-=L/o;", "\t\t\t}", "\t\t\tzero+=one[j+1]-one[j]-1;", "\t\t}", "\t}", "\tprintf(\"%lld\\n\",ret);", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 210000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\tif(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "pair<int,int>ask(vector<int>v){", "\tprintf(\"?\");", "\tstd::sort(v.begin(),v.end());", "\tfor(int i=0;i<v.size();i++){", "\t\tprintf(\" %d\",v[i]+1);", "\t}", "\tprintf(\"\\n\");", "\tfflush(stdout);", "\tint s1,s2;", "\tscanf(\"%d%d\",&s1,&s2);", "\ts1--;", "\treturn make_pair(s1,s2);", "}", "int main(){", "\tint a,b;scanf(\"%d%d\",&a,&b);", "\tpair<int,int>fi;", "\tvector<int>tmp(b);", "\tfor(int i=0;i<b;i++)tmp[i]=i;", "\tfi=ask(tmp);", "\ttmp[fi.first]=b;", "\tpair<int,int>se;", "\tse=ask(tmp);", "\tint L=0;", "\tif(fi.second<se.second){ // L < R", "\t\tfor(int i=0;i<b;i++){", "\t\t\tif(fi.first==i)continue;", "\t\t\tfor(int j=0;j<b;j++)tmp[j]=j;", "\t\t\ttmp[i]=b;", "\t\t\tpair<int,int>x=ask(tmp);", "\t\t\tif(x.second>fi.second){", "\t\t\t\tL++;", "\t\t\t}", "\t\t}", "\t}else{ // L > R", "\t\tfor(int i=0;i<b;i++){", "\t\t\tif(fi.first==i)continue;", "\t\t\tfor(int j=0;j<b;j++)tmp[j]=j;", "\t\t\ttmp[i]=b;", "\t\t\tpair<int,int>x=ask(tmp);", "\t\t\tif(x.second==fi.second){", "\t\t\t\tL++;", "\t\t\t}", "\t\t}", "\t}", "\tprintf(\"! %d\\n\",L+1);", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 210000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\tif(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int X[1100];", "int Y[1100];", "", "int main(){", "\tint a;scanf(\"%d\",&a);", "\tfor(int i=0;i<a;i++)scanf(\"%d%d\",X+i,Y+i);", "\tfor(int i=0;i<a;i++){", "\t\tX[i]+=1100000;", "\t\tY[i]+=1100000;", "\t}", "\tint B=1;", "\twhile(1){", "\t\tint L=0;", "\t\tint R=0;", "\t\tfor(int i=0;i<a;i++){", "\t\t\tif((X[i]+Y[i])%(B*2)/B)L++;", "\t\t\telse R++;", "\t\t}", "\t\tif(L&&R){", "\t\t\tvector<int>ret;", "\t\t\tfor(int i=0;i<a;i++){", "\t\t\t\tif((X[i]+Y[i])%(B*2)/B){", "\t\t\t\t\tret.push_back(i+1);", "\t\t\t\t}", "\t\t\t}", "\t\t\tprintf(\"%d\\n\",(int)ret.size());", "\t\t\tfor(int i=0;i<ret.size();i++){", "\t\t\t\tif(i)printf(\" \");", "\t\t\t\tprintf(\"%d\",ret[i]);", "\t\t\t}printf(\"\\n\");", "\t\t\treturn 0;", "\t\t}", "\t\tL=R=0;", "\t\tfor(int i=0;i<a;i++){", "\t\t\tif(X[i]%(B*2)/B)L++;", "\t\t\telse R++;", "\t\t}", "\t\tif(L&&R){", "\t\t\tvector<int>ret;", "\t\t\tfor(int i=0;i<a;i++){", "\t\t\t\tif(X[i]%(B*2)/B){", "\t\t\t\t\tret.push_back(i+1);", "\t\t\t\t}", "\t\t\t}", "\t\t\tprintf(\"%d\\n\",(int)ret.size());", "\t\t\tfor(int i=0;i<ret.size();i++){", "\t\t\t\tif(i)printf(\" \");", "\t\t\t\tprintf(\"%d\",ret[i]);", "\t\t\t}printf(\"\\n\");", "\t\t\treturn 0;", "\t\t}", "\t\tB*=2;", "\t}", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 210000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\tif(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int p[210000];", "int main(){", "\tint T;scanf(\"%d\",&T);", "\twhile(T--){", "\t\tint a,b,c;", "\t\tscanf(\"%d%d%d\",&a,&b,&c);", "\t\tbool ok=false;", "\t\tfor(int i=0;i<b;i++){", "\t\t\tint p;scanf(\"%d\",&p);", "\t\t\tif(p==a)ok=true;", "\t\t}", "\t\tfor(int i=0;i<c;i++){", "\t\t\tint p;scanf(\"%d\",&p);", "\t\t}", "\t\tif(ok)printf(\"YES\\n\");", "\t\telse printf(\"NO\\n\");", "\t}", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 210000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\tif(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int p[210000];", "int main(){", "\tint T;scanf(\"%d\",&T);", "\twhile(T--){", "\t\tint a;scanf(\"%d\",&a);", "\t\tfor(int i=0;i<a;i++){", "\t\t\tscanf(\"%d\",p+i);", "\t\t}", "\t\tbool ok=false;", "\t\tfor(int i=0;i<a-1;i++){", "\t\t\tif(ABS(p[i]-p[i+1])>=2){", "\t\t\t\tprintf(\"YES\\n\");", "\t\t\t\tprintf(\"%d %d\\n\",i+1,i+2);", "\t\t\t\tok=true;break;", "\t\t\t}", "\t\t}", "\t\tif(!ok)printf(\"NO\\n\");", "\t}", "}"]["// #pragma GCC target(\"avx\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3100000;", "const int UF_SIZE = 210000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "\tint UF[UF_SIZE];", "\tvoid init_UF(int n){", "\t\tfor(int i=0;i<n;i++)UF[i]=-1;", "\t}", "\tint FIND(int a){", "\t\tif(UF[a]<0)return a;", "\t\treturn UF[a]=FIND(UF[a]);", "\t}", "\tvoid UNION(int a,int b){", "\t\ta=FIND(a);b=FIND(b);if(a==b)return;", "\t\tif(UF[a]>UF[b])swap(a,b);", "\t\tUF[a]+=UF[b];UF[b]=a;", "\t}", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int p[110000];", "int main(){", "\tint T;scanf(\"%d\",&T);", "\twhile(T--){", "\t\tint a;scanf(\"%d\",&a);", "\t\tlong long now=0;", "\t\tlong long S=0;", "\t\tfor(int i=0;i<a;i++){", "\t\t\tscanf(\"%d\",p+i);", "\t\t\tS+=p[i];", "\t\t\tnow^=p[i];", "\t\t}", "\t\tS+=now;", "\t\tprintf(\"2\\n\");", "\t\tprintf(\"%lld %lld\\n\",now,S);", "", "\t}", "}"]["// #pragma GCC target(\"avx2\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=998244353;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3121000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int x[4000];", "int y[4000];", "long long dp[4000][2000];", "long long S[2000];", "long long T[2000];", "", "int main(){", "\tinit_C(11000);", "\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);", "\tfor(int i=0;i<c;i++){", "\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);", "\t\tp--;q--;r--;s--;", "\t\tx[p]=1;", "\t\tx[r]=1;", "\t\ty[q]=1;", "\t\ty[s]=1;", "\t}", "\tint rx=0;", "\tint ry=0;", "\tfor(int i=0;i<a;i++){", "\t\tif(x[i]==0)rx++;", "\t}", "\tfor(int i=0;i<b;i++){", "\t\tif(y[i]==0)ry++;", "\t}", "\tdp[0][0]=1;", "\tfor(int i=0;i<a;i++){", "\t\tfor(int j=0;j<=a/2;j++){", "\t\t\tif(dp[i][j]==0)continue;", "\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;", "\t\t\tif(i<a-1&&x[i]==0&&x[i+1]==0){", "\t\t\t\tdp[i+2][j+1]=(dp[i+2][j+1]+dp[i][j])%mod;", "\t\t\t}", "\t\t}", "\t}", "\tfor(int i=0;i<2000;i++)S[i]=dp[a][i];", "\tfor(int i=0;i<4000;i++)for(int j=0;j<2000;j++)dp[i][j]=0;", "\tdp[0][0]=1;", "\tfor(int i=0;i<b;i++){", "\t\tfor(int j=0;j<=b/2;j++){", "\t\t\tif(dp[i][j]==0)continue;", "\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;", "\t\t\tif(i<b-1&&y[i]==0&&y[i+1]==0){", "\t\t\t\tdp[i+2][j+1]=(dp[i+2][j+1]+dp[i][j])%mod;", "\t\t\t}", "\t\t}", "\t}", "\tfor(int i=0;i<2000;i++)T[i]=dp[b][i];", "\tlong long ret=0;", "\tfor(int i=0;i<2000;i++)for(int j=0;j<2000;j++){", "\t\tif(S[i]==0||T[j]==0)continue;", "\t\tif(i*2+j>rx)continue;", "\t\tif(j*2+i>ry)continue;", "\t\tlong long ks=Comb(rx-i*2,j)*Comb(ry-j*2,i)%mod;", "\t\tks=ks*fact[i]%mod;", "\t\tks=ks*fact[j]%mod;", "\t\tret=(ret+ks*S[i]%mod*T[j])%mod;", "\t}", "\tprintf(\"%lld\\n\",ret);", "}", ""]["// #pragma GCC target(\"avx2\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=998244353;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3121000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "pair<int,int> dp[30];", "pair<int,int> calc(int a){", "\tif(~dp[a].first)return dp[a];", "\tif(a==0){", "\t\treturn make_pair(1,0);", "\t}", "\tpair<int,int> L=calc(a-1);", "\tint M=L.first;", "\tpair<int,int> R=calc(a-1);", "\tR.second+=M+1;", "\tif(R.second%2!=M%2){", "\t\tR.first++;", "\t}", "\t// printf(\"%d: %d %d\\n\",a,L.first+R.first+1,M);", "\treturn dp[a]=make_pair(L.first+R.first+1,M);", "}", "int main(){", "\tint a;scanf(\"%d\",&a);", "\tfor(int i=0;i<30;i++)dp[i]=make_pair(-1,-1);", "\tif(a==1||a==2){", "\t\tprintf(\"1\\n\");return 0;", "\t}", "\tint sz=0;", "\tfor(int i=1;i<25;i++){", "\t\tif((1<<i)-1<=a){", "\t\t\tsz=i-1;", "\t\t}", "\t}", "\tint val=calc(sz).first;", "\tif(val==a||val+1==a)printf(\"1\\n\");", "\telse printf(\"0\\n\");", "}", ""]["// #pragma GCC target(\"avx2\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3121000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int p[310000];", "pair<int,int>ev[110000];", "int to[110000];", "int segtree[524288];", "int query(int a,int b,int c,int d,int e){", "\tif(d<a||b<c)return mod;", "\tif(c<=a&&b<=d)return segtree[e];", "\treturn min(query(a,(a+b)/2,c,d,e*2),query((a+b)/2+1,b,c,d,e*2+1));", "}", "void update(int a,int b){", "\ta+=262144;", "\twhile(a){", "\t\tsegtree[a]=min(segtree[a],b);", "\t\ta/=2;", "\t}", "}", "int ans[110000];", "int main(){", "\tint a;scanf(\"%d\",&a);", "\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);", "\tfor(int i=0;i<a;i++){", "\t\tp[i+a]=p[i];", "\t\tp[i+2*a]=p[i];", "\t\tev[i]=make_pair(p[i],i);", "\t}", "\tstd::sort(ev,ev+a);", "\tint at=0;", "\tset<int>S;", "\tS.insert(mod);", "\tfor(int i=0;i<a;i++){", "\t\twhile(at<a&&ev[at].first*2<ev[i].first){", "\t\t\tS.insert(ev[at].second);", "\t\t\tS.insert(ev[at].second+a);", "\t\t\tat++;", "\t\t}", "\t\tset<int>::iterator it=S.lower_bound(ev[i].second);", "\t\tto[ev[i].second]=(*it);", "\t}", "\tfor(int i=0;i<524288;i++)segtree[i]=mod;", "\tfor(int i=0;i<a;i++){", "\t\t// printf(\"%d\\n\",to[i]);", "\t\tupdate(i,to[i]);", "\t\tupdate(i+a,to[i]+a);\t", "\t}", "\tfor(int i=0;i<a;i++){", "\t\tint left=0;", "\t\tint right=2*a+1;", "\t\twhile(left+1<right){", "\t\t\tint M=(left+right)/2;", "\t\t\tint val=query(0,262143,i,min(i+M-1,a*2-1),1);", "\t\t\tif(val<i+M){", "\t\t\t\tright=M;", "\t\t\t}else left=M;", "\t\t}", "\t\tif(left==2*a)ans[i]=-1;", "\t\telse ans[i]=left;", "\t}", "\tfor(int i=0;i<a;i++){", "\t\tif(i)printf(\" \");", "\t\tprintf(\"%d\",ans[i]);", "\t}", "\tprintf(\"\\n\");", "}", ""]["// #pragma GCC target(\"avx2\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3121000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int X[51000];", "int Y[51000];", "int Z[51000];", "pair<pair<int,int>,pair<int,int> > p[51000];", "int v[51000];", "int main(){", "\tint a;scanf(\"%d\",&a);", "\t", "\tfor(int i=0;i<a;i++){", "\t\tscanf(\"%d%d%d\",X+i,Y+i,Z+i);", "\t\tp[i]=make_pair(make_pair(X[i],Y[i]),make_pair(Z[i],i));", "\t}", "\tstd::sort(p,p+a);", "\tfor(int i=0;i<a;i++){", "\t\tif(i&&!v[i-1]&&!v[i]&&p[i-1].first==p[i].first){", "\t\t\tprintf(\"%d %d\\n\",p[i-1].second.second+1,p[i].second.second+1);", "\t\t\tv[i-1]=v[i]=1;", "\t\t}", "\t}", "\tint pr=-1;", "\tfor(int i=0;i<a;i++){", "\t\tif(v[i])continue;", "\t\tif(pr==-1){", "\t\t\tpr=i;", "\t\t}else{", "\t\t\tif(p[i].first.first==p[pr].first.first){", "\t\t\t\tv[i]=1;", "\t\t\t\tv[pr]=1;", "\t\t\t\tprintf(\"%d %d\\n\",p[pr].second.second+1,p[i].second.second+1);", "\t\t\t\tpr=-1;", "\t\t\t}else{", "\t\t\t\tpr=i;", "\t\t\t}", "\t\t}", "\t}", "\tpr=-1;", "\tfor(int i=0;i<a;i++){", "\t\tif(v[i])continue;", "\t\tif(pr==-1){", "\t\t\tpr=i;", "\t\t}else{", "\t\t\tprintf(\"%d %d\\n\",p[pr].second.second+1,p[i].second.second+1);", "\t\t\tpr=-1;", "\t\t}", "\t}", "}", ""]["// #pragma GCC target(\"avx2\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3121000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int X[51000];", "int Y[51000];", "int Z[51000];", "pair<pair<int,int>,pair<int,int> > p[51000];", "int v[51000];", "int main(){", "\tint a;scanf(\"%d\",&a);", "\t", "\tfor(int i=0;i<a;i++){", "\t\tscanf(\"%d%d%d\",X+i,Y+i,Z+i);", "\t\tp[i]=make_pair(make_pair(X[i],Y[i]),make_pair(Z[i],i));", "\t}", "\tstd::sort(p,p+a);", "\tfor(int i=0;i<a;i++){", "\t\tif(i&&!v[i-1]&&!v[i]&&p[i-1].first==p[i].first){", "\t\t\tprintf(\"%d %d\\n\",p[i-1].second.second+1,p[i].second.second+1);", "\t\t\tv[i-1]=v[i]=1;", "\t\t}", "\t}", "\tint pr=-1;", "\tfor(int i=0;i<a;i++){", "\t\tif(v[i])continue;", "\t\tif(pr==-1){", "\t\t\tpr=i;", "\t\t}else{", "\t\t\tif(p[i].first.first==p[pr].first.first){", "\t\t\t\tv[i]=1;", "\t\t\t\tv[pr]=1;", "\t\t\t\tprintf(\"%d %d\\n\",p[pr].second.second+1,p[i].second.second+1);", "\t\t\t\tpr=-1;", "\t\t\t}else{", "\t\t\t\tpr=i;", "\t\t\t}", "\t\t}", "\t}", "\tpr=-1;", "\tfor(int i=0;i<a;i++){", "\t\tif(v[i])continue;", "\t\tif(pr==-1){", "\t\t\tpr=i;", "\t\t}else{", "\t\t\tprintf(\"%d %d\\n\",p[pr].second.second+1,p[i].second.second+1);", "\t\t\tpr=-1;", "\t\t}", "\t}", "}", ""]["// #pragma GCC target(\"avx2\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3121000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int p[110000];", "int q[110000];", "int bit[110000];", "void add(int a,int b){", "\tfor(;a<110000;a|=a+1)bit[a]+=b;", "}", "int sum(int a,int b){", "\tif(a)return sum(0,b)-sum(0,a-1);", "\tint ret=0;", "\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];", "\treturn ret;", "}", "int at[110000];", "int main(){", "\tint a;scanf(\"%d\",&a);", "\tfor(int i=0;i<a;i++){", "\t\tscanf(\"%d\",p+i);p[i]--;", "\t}", "\tfor(int i=0;i<a;i++){", "\t\tscanf(\"%d\",q+i);q[i]--;", "\t}", "\tfor(int i=0;i<a;i++){", "\t\tat[q[i]]=i;", "\t}", "\tint ret=0;", "\tfor(int i=0;i<a;i++){", "\t\tif(sum(at[p[i]],a-1))ret++;", "\t\tadd(at[p[i]],1);", "\t}", "\tprintf(\"%d\\n\",ret);", "}", ""]["// #pragma GCC target(\"avx2\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3121000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint pw_mod_int(int a,int b,int M){", "\t\tif(a<0)return 0;", "\t\tif(b<0)return 0;", "\t\tint ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=(long long)ret*a%M;", "\t\t\ta=(long long)a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int p[21000];", "int v[21000];", "int main(){", "\tint a;scanf(\"%d\",&a);", "\tint cnt=0;", "\tfor(int i=0;i<a;i++){", "\t\tscanf(\"%d\",p+i);", "\t\tif(ABS(p[i])%2){", "\t\t\tcnt++;", "\t\t}", "\t}", "\tcnt/=2;", "\tfor(int i=0;i<a;i++){", "\t\tif(ABS(p[i])%2==0){", "\t\t\tp[i]/=2;", "\t\t}else{", "\t\t\tif(cnt>0){", "\t\t\t\tp[i]=(p[i]+1)/2;", "\t\t\t}else{", "\t\t\t\tp[i]=(p[i]-1)/2;", "\t\t\t}", "\t\t\tcnt--;", "\t\t}", "\t}", "\tfor(int i=0;i<a;i++)printf(\"%d\\n\",p[i]);", "}", ""]["// #pragma GCC target(\"avx2\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1008691207;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3121000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int p[310000];", "int par[310000];", "int num[310000];", "int cnt[310000];", "map<pair<int,int>,int>M;", "int main(){", "\tint Q;scanf(\"%d\",&Q);", "\twhile(Q--){", "\t\tint a;scanf(\"%d\",&a);", "\t\tfor(int i=0;i<a;i++){", "\t\t\tscanf(\"%d\",p+i);", "\t\t\tp[i]--;", "\t\t}", "\t\tfor(int i=0;i<=a+10;i++){", "\t\t\tpar[i]=num[i]=cnt[i]=0;", "\t\t}", "\t\tM.clear();", "\t\tlong long ret=0;", "\t\tint at=0;", "\t\tint sz=1;", "\t\tnum[at]=-1;", "\t\tcnt[at]=1;", "\t\tfor(int i=0;i<a;i++){", "\t\t\tif(p[i]==num[at]){", "\t\t\t\tat=par[at];", "\t\t\t}else{", "\t\t\t\tif(M.count(make_pair(at,p[i]))){", "\t\t\t\t\tint id=M[make_pair(at,p[i])];", "\t\t\t\t\tat=id;", "\t\t\t\t}else{", "\t\t\t\t\tM[make_pair(at,p[i])]=sz;", "\t\t\t\t\tnum[sz]=p[i];", "\t\t\t\t\tpar[sz]=at;", "\t\t\t\t\tat=sz;", "\t\t\t\t\tsz++;", "\t\t\t\t}", "\t\t\t}", "\t\t\tret+=cnt[at];", "\t\t\tcnt[at]++;", "\t\t}", "\t\tprintf(\"%lld\\n\",ret);", "\t}", "}"]["// #pragma GCC target(\"avx2\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1008691207;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3121000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "vector<pair<int,int> >g[510000];", "long long dp[510000][2];", "pair<long long,int> tmp[510000];", "int K;", "void calc(int a,int b,int c){", "\tfor(int i=0;i<g[a].size();i++){", "\t\tif(b==g[a][i].first)continue;", "\t\tcalc(g[a][i].first,a,g[a][i].second);", "\t}", "\tint sz=0;", "\tfor(int i=0;i<g[a].size();i++){", "\t\tif(b==g[a][i].first)continue;", "\t\ttmp[sz++]=make_pair(dp[g[a][i].first][1]-dp[g[a][i].first][0],g[a][i].first);", "\t}", "\tstd::sort(tmp,tmp+sz);", "\treverse(tmp,tmp+sz);", "\tlong long bk=0;", "\tlong long bk1=0;", "\tfor(int i=0;i<sz;i++){", "\t\tint at=tmp[i].second;", "\t\tif(i<K){", "\t\t\tbk+=max(dp[at][0],dp[at][1]);", "\t\t}else{", "\t\t\tbk+=dp[at][0];", "\t\t}", "\t\tif(i<K-1){", "\t\t\tbk1+=max(dp[at][0],dp[at][1]);", "\t\t}else{", "\t\t\tbk1+=dp[at][0];", "\t\t}", "\t}", "\tdp[a][0]=bk;", "\tdp[a][1]=bk1+c;", "}", "int main(){", "\tint Q;scanf(\"%d\",&Q);", "\twhile(Q--){", "\t\tint a,b;scanf(\"%d%d\",&a,&b);", "\t\tK=b;", "\t\tfor(int i=0;i<a;i++){", "\t\t\tg[i].clear();", "\t\t\tdp[i][0]=dp[i][1]=0LL;", "\t\t}", "\t\tfor(int i=0;i<a-1;i++){", "\t\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);p--;q--;", "\t\t\tg[p].push_back(make_pair(q,r));", "\t\t\tg[q].push_back(make_pair(p,r));", "\t\t}", "\t\tcalc(0,-1,0);", "\t\tprintf(\"%lld\\n\",dp[0][0]);", "\t}", "}"]["// #pragma GCC target(\"avx2\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1008691207;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3121000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int p[310000];", "int L[310000];", "int R[310000];", "int main(){", "\tint Q;scanf(\"%d\",&Q);", "\twhile(Q--){", "\t\tint a;scanf(\"%d\",&a);", "\t\tfor(int i=0;i<a;i++){", "\t\t\tscanf(\"%d\",p+i);", "\t\t\tp[i]--;", "\t\t}", "\t\tfor(int i=0;i<a;i++)L[i]=mod;", "\t\tint sh=0;", "\t\tfor(int i=0;i<a;i++){", "\t\t\tL[p[i]]=min(L[p[i]],i);", "\t\t\tR[p[i]]=i;", "\t\t}", "\t\tfor(int i=0;i<a;i++){", "\t\t\tif(L[i]!=mod)sh++;", "\t\t}", "\t\tint lg=0;", "\t\tint pr=mod;", "\t\tint lm=0;", "\t\tfor(int i=0;i<a;i++){", "\t\t\tif(L[i]==mod)continue;", "\t\t\tif(pr==mod){", "\t\t\t\tpr=R[i];", "\t\t\t\tlg=1;", "\t\t\t}else if(pr<L[i]){", "\t\t\t\tlg++;", "\t\t\t\tpr=R[i];", "\t\t\t}else{", "\t\t\t\tlg=1;", "\t\t\t\tpr=R[i];", "\t\t\t}", "\t\t\tlm=max(lm,lg);", "\t\t}", "\t\tprintf(\"%d\\n\",sh-lm);", "\t}", "}"]["// #pragma GCC target(\"avx2\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"O3\")  // CPU \u51e6\u7406\u4e26\u5217\u5316", "// #pragma GCC optimize(\"unroll-loops\")  // \u6761\u4ef6\u51e6\u7406\u306e\u547c\u3073\u51fa\u3057\u3092\u6e1b\u3089\u3059", "#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "#include<numeric>", "#include<unordered_set>", "#include<complex>", "using namespace std;", "const long long mod=1008691207;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const double EPS=1e-10;", "const double INF=1e+10;", "const double PI=acos(-1.0);", "const int C_SIZE = 3121000;", "namespace{", "\tlong long fact[C_SIZE];", "\tlong long finv[C_SIZE];", "\tlong long inv[C_SIZE];", "\tlong long Comb(int a,int b){", "\t \tif(a<b||b<0)return 0;", "\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;", "\t}", "\tvoid init_C(int n){", "\t\tfact[0]=finv[0]=inv[1]=1;", "\t\tfor(int i=2;i<n;i++){", "\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;", "\t\t}", "\t\tfor(int i=1;i<n;i++){", "\t\t\tfact[i]=fact[i-1]*i%mod;", "\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;", "\t\t}", "\t}", "\tlong long pw(long long a,long long b){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%mod;", "\t\t\ta=a*a%mod;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tlong long pw_mod(long long a,long long b,long long M){", "\t\tif(a<0LL)return 0;", "\t\tif(b<0LL)return 0;", "\t\tlong long ret=1;", "\t\twhile(b){", "\t\t\tif(b%2)ret=ret*a%M;", "\t\t\ta=a*a%M;", "\t\t\tb/=2;", "\t\t}", "\t\treturn ret;", "\t}", "\tint ABS(int a){return max(a,-a);}", "\tlong long ABS(long long a){return max(a,-a);}", "\tdouble ABS(double a){return max(a,-a);}", "\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }", "}", "// \u3053\u3053\u304b\u3089\u7de8\u96c6\u3057\u308d", "int p[210000];", "int gcd(int a,int b){", "\twhile(a){", "\t\tb%=a;swap(a,b);", "\t}return b;", "}", "long long lcm(int a,int b){", "\treturn (long long)a/gcd(a,b)*b;", "}", "int main(){", "\tint Q;scanf(\"%d\",&Q);", "\twhile(Q--){", "\t\tint a;scanf(\"%d\",&a);", "\t\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);", "\t\tstd::sort(p,p+a);", "\t\treverse(p,p+a);", "\t\tint x,c,y,d;", "\t\tscanf(\"%d%d%d%d\",&x,&c,&y,&d);", "\t\tif(x<y){", "\t\t\tswap(x,y);", "\t\t\tswap(c,d);", "\t\t}", "\t\tlong long s=lcm(c,d);", "\t\tlong long e;scanf(\"%lld\",&e);", "\t\tint left=0;", "\t\tint right=a+1;", "\t\twhile(left+1<right){", "\t\t\tint M=(left+right)/2;", "\t\t\tlong long cur=0;", "\t\t\tint A=M/s;", "\t\t\tint B=M/c-A;", "\t\t\tint C=M/d-A;", "\t\t\tfor(int i=0;i<A;i++){", "\t\t\t\tcur+=p[i]/100*(x+y);", "\t\t\t}", "\t\t\tfor(int i=0;i<B;i++){", "\t\t\t\tcur+=p[A+i]/100*(x);", "\t\t\t}", "\t\t\tfor(int i=0;i<C;i++){", "\t\t\t\tcur+=p[A+B+i]/100*(y);", "\t\t\t}", "\t\t\t", "\t\t\tif(cur>=e){", "\t\t\t\tright=M;", "\t\t\t}else left=M;", "\t\t}", "\t\tif(right>a){", "\t\t\tright=-1;", "\t\t}", "\t\tprintf(\"%d\\n\",right);", "\t}", "}"]["#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const long double EPS=1e-9;", "const long double PI=acos(-1.0);", "int ABS(int a){return max(a,-a);}", "long long ABS(long long a){return max(a,-a);}", "long double ABS(long double a){return max(a,-a);}", "long long x[210000];", "long long y[210000];", "pair<long long,long long>p[210000];", "int bit[210000];", "int sum(int a,int b){", "\tif(a>b)return 0;", "\tif(a)return sum(0,b)-sum(0,a-1);", "\tint ret=0;", "\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];", "\treturn ret;", "}", "void add(int a,int b){", "\tfor(;a<210000;a|=a+1)bit[a]+=b;", "}", "", "int main(){", "\tint a;scanf(\"%d\",&a);", "\tfor(int i=0;i<a;i++){", "\t\tscanf(\"%lld%lld\",x+i,y+i);", "\t\tp[i]=make_pair(-y[i],x[i]);", "\t}", "\tstd::sort(p,p+a);", "\tstd::sort(x,x+a);", "\tlong long ret=0;", "\tlong long act=0;", "\tint L=mod;", "\tint R=-1;", "\tvector<int>zz;", "\tfor(int i=0;i<a;i++){", "\t\tlong long X=p[i].second;", "\t\tlong long Y=p[i].first;", "\t\tint zh=lower_bound(x,x+a,X)-x;", "\t\tL=min(L,zh);", "\t\tR=max(R,zh);", "\t\tif(sum(zh,zh)==0){", "\t\t\tact++;", "\t\t\tadd(zh,1);", "\t\t}", "\t\tzz.push_back(zh);", "", "\t\tif(i==a-1||p[i].first!=p[i+1].first){", "\t\t\tzz.push_back(-1);", "\t\t\tzz.push_back(205000);", "\t\t\tstd::sort(zz.begin(),zz.end());", "", "\t\t\tret+=(act+1)*act/2;", "\t\t\tfor(int j=0;j+1<zz.size();j++){", "\t\t\t\tlong long tmp=sum(zz[j]+1,zz[j+1]-1);", "\t\t\t\tret-=tmp*(tmp+1)/2;", "\t\t\t}", "\t\t\tzz.clear();", "\t\t}", "\t}", "\tprintf(\"%lld\\n\",ret);", "}"]["#include<stdio.h>", "#include<math.h>", "#include<algorithm>", "#include<queue>", "#include<deque>", "#include<stack>", "#include<string>", "#include<string.h>", "#include<vector>", "#include<set>", "#include<map>", "#include<bitset>", "#include<stdlib.h>", "#include<cassert>", "#include<time.h>", "#include<bitset>", "using namespace std;", "const long long mod=1000000007;", "const long long inf=mod*mod;", "const long long d2=(mod+1)/2;", "const long double EPS=1e-9;", "const long double PI=acos(-1.0);", "int ABS(int a){return max(a,-a);}", "long long ABS(long long a){return max(a,-a);}", "long double ABS(long double a){return max(a,-a);}", "char in[110000];", "vector<int>ind[2];", "int cnt(int L,int R,int t){", "\tif(R<L)return 0;", "\treturn upper_bound(ind[t].begin(),ind[t].end(),R)-lower_bound(ind[t].begin(),ind[t].end(),L);", "}", "int main(){", "\tint a,b;scanf(\"%d%d\",&a,&b);", "\tscanf(\"%s\",in);", "\tint ret=0;", "\tfor(int i=0;i<a;i++){", "\t\tind[in[i]-'0'].push_back(i);", "\t}", "\tfor(int i=0;i<=a-b;i++){", "\t\tint c0=cnt(0,i-1,0)+cnt(i+b,a-1,0);", "\t\tint c1=cnt(0,i-1,1)+cnt(i+b,a-1,1);", "\t\tif(c0==0||c1==0){", "\t\t\tret=2;break;", "\t\t}", "\t\tint l0=ind[0][0];", "\t\tint l1=ind[1][0];", "\t\tint r0=ind[0][ind[0].size()-1];", "\t\tint r1=ind[1][ind[1].size()-1];", "\t\tif(i<=l0&&l0<i+b){", "\t\t\tl0=*(lower_bound(ind[0].begin(),ind[0].end(),i+b));\t", "\t\t}", "\t\tif(i<=l1&&l1<i+b){", "\t\t\tl1=*(lower_bound(ind[1].begin(),ind[1].end(),i+b));\t", "\t\t}", "\t\tif(i<=r0&&r0<i+b){", "\t\t\tr0=*(lower_bound(ind[0].begin(),ind[0].end(),i)-1);", "\t\t}", "\t\tif(i<=r1&&r1<i+b){", "\t\t\tr1=*(lower_bound(ind[1].begin(),ind[1].end(),i)-1);", "\t\t}", "\t\tif(r0-l0>=b||r1-l1>=b){", "\t\t\tret=1;", "\t\t}", "\t}", "\tif(ret==0)printf(\"quailty\\n\");", "\telse if(ret==1)printf(\"once again\\n\");", "\telse printf(\"tokitsukaze\\n\");", "}"]